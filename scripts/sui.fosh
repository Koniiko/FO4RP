#ifndef __SUI__
    #define __SUI__

    #include "sui_defines.fosh"
    #include "sui_events.fosh"
    #include "sui_event_listeners.fosh"

    #ifdef __CLIENT
        #include "sui_input.fosh"
    #endif

    // Parent class for all of the submodules
    shared class ModuleSUI 
    {
        // Module ID assigned by framework
        uint ModuleID;

        // Framework reference
        FrameworkSUI@ SUI;

        // Default constructor
        ModuleSUI(FrameworkSUI@ sui) final {
            sui.AddModule(this);
        }
    }

    //
    // Main module that is returned as SUI and is also injected in every submodule class as .SUI
    // Provides access from submodules to submodules
    // Connects engine events & misc calls into SUI-events, manages loaded modules
    //
    shared class FrameworkSUI
    {
        ModuleSUI@[] Modules;

        // Generic event listeners collection
        EventListenerSUI@[] EventListeners;

        // loop() event listeners collection - separate from generic events in order to reduce load
        LoopListenerSUI@[] LoopListeners;

        #ifdef __CLIENT 
            // render_iface() & render_map() listeners collection - separate from generic & loop events in order to reduce load
            RenderListenerSUI@[] RenderListeners;
            
            HotkeyListenerSUI@ Hotkeys;
        #endif

        // Limited amount of loop listeners that are fired on every loop() call
        uint LoopChunkSize;
        
        // Current offset of that amount within the whole event listeners group
        uint LoopChunkOffset;

        //
        // Constructor
        //
        FrameworkSUI() final {
            this.EventListeners.resize(0);
            this.LoopListeners.resize(0);

            this.LoopChunkSize = 32;
            this.LoopChunkOffset = 0;

            #ifdef __CLIENT
                this.RenderListeners.resize(0);
            #endif 

            // Built-in submodules registration
            #ifdef __CLIENT
                @this.Hotkeys = HotkeyListenerSUI(this);
            #endif
        }

        // 
        // Event methods
        //

        bool Dispatch(EventSUI@ event) final {
            EngineEventSUI@ engineEvent = cast<EngineEventSUI>(event);

            for (uint i = 0, l = this.EventListeners.length; i < l; i++) {
                this.EventListeners[i].OnEvent(event);
                if (event.StopPropagation) break;
            }

            if (null is engineEvent) {
                return false;
            }

            return engineEvent.StopProcessing;
        }

        //
        // Subscriber methods
        //

        void AddModule(ModuleSUI@ module) final {
            this.Modules.insertLast(module);
            module.ModuleID = this.Modules.length - 1;
            @module.SUI = this;
        }

        void AddEventListener(EventListenerSUI@ eventListener) final {
            this.EventListeners.insertLast(eventListener);
        }

        void AddLoopListener(LoopListenerSUI@ loopListener) final {
            this.LoopListeners.insertLast(loopListener);
        }

        #ifdef __CLIENT
            void AddRenderListener(RenderListenerSUI@ renderListener) final {
                this.RenderListeners.insertLast(renderListener);
            }
        #endif

        //
        // Event & engine callback hooks
        //

        bool Start() { 
            return false;
        }

        void Loop() {
            for (
                uint i = 0, 
                     l = this.LoopListeners.length > this.LoopChunkSize ? this.LoopChunkSize : this.LoopListeners.length;
                i < l;
                i++
            ) {
                this.LoopListeners[i].OnLoop();
            }

            if (this.LoopChunkOffset + this.LoopChunkSize > this.LoopListeners.length) {
                this.LoopChunkOffset = 0;
            } else {
                this.LoopChunkOffset += this.LoopChunkSize;
            }
        }

        // Seems like sometimes module is unloaded before finish, so we wont use it for now
        // void Finish() {}

        #ifdef __SERVER

            void Init() {
                // ...
            }

        #endif

        #ifdef __CLIENT

            bool MouseDown(int key) {
                EngineEventSUI@ event = MouseStateEventSUI(key, true);
                this.Dispatch(event);

                // FOnline productes no /up/ events for mouse scroll and so we mimick them
                if (3 == key || 4 == key) { 
                    this.Dispatch(MouseStateEventSUI(key, false));
                }

                return event.StopProcessing;
            }

            bool MouseUp(int key) {
                EngineEventSUI@ event = MouseStateEventSUI(key, false);
                this.Dispatch(event);
                return event.StopProcessing;
            }

            bool KeyDown(uint8 key) {
                EngineEventSUI@ event = KeyboardStateEventSUI(key, true);
                this.Dispatch(event);
                return event.StopProcessing;
            }

            bool KeyUp(uint8 key) {
                EngineEventSUI@ event = KeyboardStateEventSUI(key, false);
                this.Dispatch(event);
                return event.StopProcessing;
            }

            void MouseMove(int x, int y) {
                InputEventSUI@ event = MouseMoveEventSUI(x, y);
                this.Dispatch(event);
            }

            void InputLost() {
                InputEventSUI@ event = InputLostEventSUI();
                this.Dispatch(event);
            }

        #endif
    }

    // Exports sui.fos' FrameworkSUI preconfigured implementation so that it is available as SUI virtual variable 
    // in a current context outside of SUI modules

    #ifndef __MODULE_SUI__
        #define __MODULE_SUI__
        import FrameworkSUI@ get_SUI() from "sui"; 
    #endif

#endif