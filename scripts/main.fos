#include "_utils.fos"
#include "teams_table.fos"
#include "sui.fosh"

#include "_teams.fos" //Он вообще нужен?
#include "miniutils_h.fos" //Переделать в полноценный "var.fos"

//Возможно, стоит засунуть в "_utils.fos"
#include "_npc_pids.fos"
#include "wait_time_h.fos"

#include "apregen_h.fos"

#define __MAIN_MODULE__
#include "_global_events.fos"
#include "_ltp.fos"
#include "npc_names_holder_h.fos"

#include "combat_h.fos"

#include "_colors.fos"
// Imports
import void CheckCartPicMap( Item& furniture ) from "furniture";

import void InitializeGame() from "config";
import bool OnUseExplode( Critter& cr, Item& explode, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen, uint timer ) from "explode";
//import bool IsStill( Item@ item ) from "manufact_alco";
//import bool UseStill( Critter@ cr, Item@ still, int skill, Item@ item ) from "manufact_alco";
//import bool IsTree( Scenery@ scen ) from "scenery";
//import bool UseAxeOnTree( Critter@ cr, Scenery@ tree ) from "scenery";
import bool UseItemOnCar( Critter& cr, Item& car, Item& item ) from "car";
import bool UseSkillOnCar( Critter& cr, Item& car, int skill ) from "car";

import void DropPoison( Critter& cr ) from "poison";                    // TabaK
import void DropParalysis( Critter& cr, int value ) from "paralysis";   // Для противоядия
import void AffectParalysis( Critter& cr, int value ) from "paralysis"; // и яда
import void DropParalysisInstant( Critter& cr ) from "paralysis";
import void DropRadiation( Critter& cr ) from "radiation";
import void AffectRadiation( Critter& cr, int value ) from "radiation";
import void SetHair( Critter& cr ) from "hair";
import void RestartHair( Critter& cr ) from "hair";
import void HairCut( Critter& cr, Critter& onCr ) from "hair";
import void Shave( Critter& cr, Critter@ onCr ) from "hair";

import void WorldmapInit() from "worldmap";
import void CombatAttack( Critter& cr, Critter@ target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo, uint16 hexX, uint16 hexY ) from "combat";
import void AskCooking( Critter& cr ) from "cooking";
import bool AskAction( Critter& cr, Item& item ) from "repair";

import bool WantedSignSet( Item& wantedSign, string& name, uint cost ) from "wanted";
import bool IsReadableBook( uint16 pid ) from "books";
import void TryReadBook( Critter& cr, Item& book ) from "books";
import void UseDrug( Critter& cr, Item& drug ) from "drugs";
import void UseDrugOn( Critter& cr, Critter& onCr, Item& drug ) from "drugs";
import bool UseGeiger( Critter& cr, Item& geiger ) from "geiger";
import bool UseItemOnGeiger( Critter& cr, Item& geiger, Item& item ) from "geiger";
import bool UseSkillOnGeiger( Critter& cr, Item& geiger, int skill ) from "geiger";
// import void CallTownSupply(Critter& victim, Critter& hostile) from "town_supply";
import bool AddAttackPlane( Critter& npc, uint priority, Critter& target ) from "npc_planes";
import bool AddAttackPlane( Critter& npc, uint priority, Critter& target, int minHp ) from "npc_planes";
import bool UseSkillOnLocker( Critter& cr, Item& locker, int skill ) from "lockers";
import bool UseItemOnLocker( Critter& cr, Item& locker, Item& item ) from "lockers"; // Export pm added
import bool PerkCheck( Critter& cr, uint perk ) from "perks";
import void CritterGenerate( Critter& cr ) from "parameters";
// import void CaravansInit() from "caravan";
import int  GetDeteriorationProcent( Item& item ) from "repair";
import void SetDeterioration( Item& item, int deteriorationProcent ) from "repair";
import void NpcProcessLevel( Critter& npc ) from "parameters";
// import bool ProtoItem_Weapon_IsHtHAttack( ProtoItem& proto, uint8 mode ) from "parameters";

import void EditRadioSettings( Critter& player, Item& radio ) from "radio";

import void skin( Critter& cr, int crType ) from "skins";

import void qmap_critter_in( uint mapId, Critter& cr ) from "qmap";
import void qmap_critter_out( uint mapId, Critter& cr ) from "qmap";
import void qmap_save_all() from "qmap";
import void qmap_load_all() from "qmap";

import bool UseShovel( Critter& cr, Item& item ) from "farm";
import void ApplyMutation( Critter& cr ) from "morphes";

import bool unlock( Critter& cr, Critter& targetCr, uint16 pid ) from "handcuffs"; // pm add
import void ChangeCritterSpeed( Critter& cr ) from "speed";                        // pm add

import int AddNewCritterHistoryBase( Critter& cr ) from "history_menu";            // pm menu

import bool e_InitSkinningUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery ) from "mob";

import string SetupAidLeX( uint8 aidValue ) from "item";

import void CheckFaction( Critter& cr, bool join ) from "factions";

import bool IsHaveBlade( uint16 pid ) from "repair";                             // pm added
import void robotRepairSkill (Critter& cr, Critter& targetCr, bool alreadyAllowed) from "repair";

import bool ItemStimpackUse( Critter& cr, Item& item ) from "heal";
import bool __Bandage( Critter& cr, Critter@ targetCr ) from "heal";
import void ItemHypoUse (Critter& cr, Item& item) from "heal"; //Гипо
import void ItemSupUse(Critter& cr, Item& item) from "heal"; //Суперстим СС

import void InitCrimsonCaravans() from "crimson_caravans";
import void SaveCaravans() from "crimson_caravans";
import void Log_Steal( Critter& player, int target, int item, int succes, string@ param3, int[] @ param4 ) from "gm";

import void ProccessFood( Critter& cr, Critter& target, Item& item ) from "item";

import void InitTiles() from "cimp";

import bool LighterOnFire( Critter& cr, Item& lighter, Scenery& fire ) from "cooking";
import bool UseCookingStuff( Scenery& scen, Critter& cr ) from "cooking";
import bool CanCook( Scenery@ fire ) from "cooking";

import bool IsDoorAutomatic( uint pid ) from "map_sutter_objects";
//EFFECTS
import void FlushScreen( Critter& cr, uint fromColor, uint toColor, uint timeMs ) from "effects";

import bool AddWalkPlane( Critter& npc, uint priority, uint16 hexX, uint16 hexY, uint8 dir, bool run, uint cut ) from "npc_planes";

import bool e_Repair( Item& item, Critter& cr, Item@ usedItem ) from "adv_items";

import void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, int attackerId ) from "combat";
import bool SetTrapOnItem( Critter& cr, Item& trap, Item& onItem ) from "trap";

// Mio import
import void DiceUse( Critter& cr, Item& item ) from "mio_social";
import void CardsUse( Critter& cr, Item& item ) from "mio_social";
import void CoinUse( Critter& cr, Item& item ) from "mio_social";
import void ShowTheWay( Critter& cr, Critter@ targetCr ) from "mio_social";
import void LordOfDestruction( Critter& cr, Item& item, int8 type ) from "mio_social";

import void DescriptionUse( Critter& player, Item& item ) from "mio_tests";
import void ScouringStick( Critter& cr, Item& item ) from "mio_tests";

import void registerTraps() from "traps";
import void registerMines() from "traps_mines";

import void brahminInitSearch( Critter& cr ) from "brahmins";
import bool BrahminPetting( Critter& cr, Item& item, Critter@ targetCr ) from "brahmins";

import NpcNamesHolder@ getNpcNamesHolder() from "npc_names_holder";

import bool PrepareScavenging( Critter& cr, Item@ tool, Item@ target ) from "scavenging";
import bool PrepareChopping( Critter& cr, Item@ tool, Item@ target ) from "chopping";
import bool PrepareMining( Critter& cr, Item@ item, Item@ targetItem ) from "mining";
import bool SlotMachineCheck( Critter& cr, Item@ cash, Item@ target ) from "casino";
import bool FireCheck( Critter& cr, Item@ item, Item@ target ) from "firestarter";
import bool Ignite( Critter& cr, Item& item, Item& target ) from "firestarter";
import bool ShowMenuFireBarrel( Critter& cr, Item& target ) from "firestarter";
import bool ShowMenuBrew( Critter& cr, Item& target ) from "homebrew";
import bool TransferToPot( Critter& cr, Item& targetItem, Item& cont ) from "homebrew";
import bool TransferFromPot( Critter& cr, Item& targetItem, Item& cont ) from "homebrew";
import bool drinkHomebrew( Critter& cr, Item& item ) from "homebrew";
import bool IsStill(Item& still)  from "bootlegging";
import bool UseItemOnStill( Critter& cr, Item@ item, Item@ target )  from "bootlegging";
import void ShowMenuStill( Critter& cr, Item& target ) from "bootlegging";
import bool TransferToStill( Critter& cr, Item& targetItem, Item& cont ) from "bootlegging";
import void StartMenuSlotMachine( Critter& cr, Item& target) from "casino";
import void StartMenuVendingMachine( Critter& cr, Item& target) from "vending";

const uint16[] water_sources = { PID_BADYA, 2615, 2619, 2621, 2622, 2623, 2624, 2625, 2626, 2894, 2895, 23365 };
const uint16[] Stills = { PID_STILL_B, PID_STILL_B_BROKEN, PID_STILL_S, PID_STILL_S_BROKEN };
const uint16[] wildplants = { PID_PLANT_BROC, PID_PLANT_XANDER, PID_PLANT_TONGUE_GECKO, PID_PLANT_MURAVNIKTAR, PID_PLANT_BLACK_MUSHROOMS,
								  PID_PLANT_PALE_MUSHROOM, PID_PLANT_MUTMUSH };

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called before world generation.
void init()
{
    InitializeGame();
	SUI.Init();
}

uint16 GetVersionWorldSave( ::string@ time )
{
    ::array< uint > data;
    if( IsAnyData( "VersionWorldSave" ) && ::GetAnyData( "VersionWorldSave", data ) )
    {
        if( valid( time ) )
            time = "" + data[ 1 ] + "_" + data[ 2 ] + "_" + data[ 3 ] + "_" + data[ 4 ] + "_" + data[ 5 ];
        return data[ 0 ] % 9999;
    }
    return 0;
}

bool SaveWorldNextVersion()
{
    uint16 Year = 0, Month = 0, Day = 0, Hour = 0, Minute = 0, var = 0;
    GetTime( Year, Month, Day, var, Hour, Minute, var, var );
    ::array< uint > data = { GetVersionWorldSave( null ) + 1, Year, Month, Day, var, Hour, Minute };
	file version;
	if( version.open( "WorldVersion","w") != -1 )
	{	
		version.writeString( "" + data[0] );
		version.close();
	}
    return ::SetAnyData( "VersionWorldSave", data );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on start server.
bool start()
{
    // Send info about others critters
    // Remember:
    // - all this info can be hacked in client;
    // - more parameters - more traffic.
    SetSendParameter( ST_GENDER, true );
    SetSendParameter( ST_AGE, true );
    SetSendParameter( ST_FOLLOW_CRIT, true );
    SetSendParameter( ST_PLAYER_KARMA, true );
    // Armor class, uses Agility
    SetSendParameter( ST_ARMOR_CLASS, true );
    SetSendParameter( ST_TURN_BASED_AC, true );
    // Agility
    SetSendParameter( ST_AGILITY, true );
    // Hit points, uses Strenght and Endurance
    SetSendParameter( ST_MAX_LIFE, true );
    SetSendParameter( ST_CURRENT_HP, true );
 /*   SetSendParameter(BP_HEAD_HP, true);
    SetSendParameter(BP_TORSO_HP, true);
    SetSendParameter(BP_GROIN_HP, true);
    SetSendParameter(BP_EYES_HP, true);
    SetSendParameter(BP_RIGHT_ARM_HP, true);
    SetSendParameter(BP_LEFT_ARM_HP, true);
    SetSendParameter(BP_RIGHT_LEG_HP, true);
    SetSendParameter(BP_LEFT_LEG_HP, true);*/
    // Strenght, uses battle timeout
    SetSendParameter( ST_STRENGTH, true );
    SetSendParameter( PE_ADRENALINE_RUSH, true );
    // Battle timeout
    SetSendParameter( TO_BATTLE, true );
    // Endurance
    SetSendParameter( ST_ENDURANCE, true );
    // Charisma
    SetSendParameter( ST_CHARISMA, true );
	SetSendParameter( ST_CHARISMA_EXT, true );
    // Mio Flags
    SetSendParameter( MIO_FLAGS, true );
    // Injures
    SetSendParameter( DAMAGE_EYE, true );
    SetSendParameter( DAMAGE_RIGHT_ARM, true );
    SetSendParameter( DAMAGE_LEFT_ARM, true );
    SetSendParameter( DAMAGE_RIGHT_LEG, true );
    SetSendParameter( DAMAGE_LEFT_LEG, true );
    // Item slots, passed with -
    SetSendParameter( -SLOT_HAND1, true, "fonline_tnf.dll@allowSlot_Hand1" );
    SetSendParameter( -SLOT_ARMOR, true );
	SetSendParameter( -SLOT_MISC, true );
	SetSendParameter( -SLOT_HEAD, true );
	SetSendParameter( -SLOT_BACK, true );
    // Some flags for correct client working
    SetSendParameter( MODE_NO_BARTER, true );
    SetSendParameter( MODE_NO_STEAL, true );
    SetSendParameter( MODE_NO_LOOT, true );
    SetSendParameter( MODE_NO_FLATTEN, true );
    SetSendParameter( MODE_NO_TALK, true );
    // 3d animation layers
// #ifdef PLAYERS_3D
    // Enable sending 3d layers, from Skin to Backpack
    uint fromLayer = ST_ANIM3D_LAYERS + ANIM3D_LAYER_SKIN;
    uint toLayer = ST_ANIM3D_LAYERS + ANIM3D_LAYER_BACKPACK;
    for( uint i = fromLayer; i <= toLayer; i++ )
        SetSendParameter( i, true );
// #endif
    // Npc talk distance
    SetSendParameter( ST_TALK_DISTANCE, true );
    // Dialog id
    SetSendParameter( ST_DIALOG_ID, true );
    // To see pid of unarmed attack
    SetSendParameter( ST_HANDS_ITEM_AND_MODE, true );
    // Scale factor
    SetSendParameter( ST_SCALE_FACTOR, true );
    // Walk / Run speed
    SetSendParameter( ST_WALK_TIME, true );
    SetSendParameter( ST_RUN_TIME, true );

    SetSendParameter( SK_BARTER, true );
    // Аркадный режим
    SetSendParameter( QST_GAMEMODE, true );
    // Language barrier - binyan
    SetSendParameter( ST_BODY_TYPE, true );
	
    SetSendParameter( QST_MEDIUM, true );
	
	SetSendParameter( CR_IS_AGGRESSIVE, true );
	SetSendParameter( TRAIT_GOOD_NATURED, true );
	SetSendParameter( TRAIT_BLOODY_MESS, true );

	SetSendParameter( ST_CURRENT_AP, true );
	SetSendParameter( ST_ACTION_POINTS, true );
	SetSendParameter( CR_DIRTINESS, true );
	SetSendParameter( CR_FITNESS, true );
	SetSendParameter( CR_RELAXED, true );
	SetSendParameter( CR_TYPING_TIME, true );

    // charsheet&visibility
    SetSendParameter( QST_CHAR_VER, true );
    SetSendParameter( QST_CHAR_SECRET, true );
	SetSendParameter( QST_INVIS, true );

    // Send item data masks
    // Look fields in fonline.h 'struct Item::ItemData'
    //               SortValue  Info Indicator    PicMapHash       PicInvHash   AnimWaitBase AStay[2] AShow[2] AHide[2]      Flags      Rate LightDist Inten Flags  LightColor    ScriptId TrapValue       Count             Cost                ScriptValues[10]                                                                                                   Other 36 bytes
    // ITEM_DATA_MASK_CHOSEN                                                                                           ITEM_DATA_MASK_CHOSEN                                                                                                ITEM_DATA_MASK_CHOSEN
    int8[] mask0 = {  -1, -1,     -1,   -1,     -1, -1, -1, -1,  -1, -1, -1, -1,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    // ITEM_DATA_MASK_CRITTER                                                                                          ITEM_DATA_MASK_CRITTER                                                                                               ITEM_DATA_MASK_CRITTER
    int8[] mask1 = {   0,  0,     -1,    0,      0,  0,  0,  0,   0,  0,  0,  0,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,     0,  0,  0,  0,   0,  0,  0,  0,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0 };
    // ITEM_DATA_MASK_CRITTER_EXT                                                                                      ITEM_DATA_MASK_CRITTER_EXT                                                                                           ITEM_DATA_MASK_CRITTER_EXT
    int8[] mask2 = {   0,  0,     -1,   -1,      0,  0,  0,  0,   0,  0,  0,  0,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,    -1, -1, -1, -1,   0,  0,  0,  0,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    // ITEM_DATA_MASK_CONTAINER                                                                                        ITEM_DATA_MASK_CONTAINER                                                                                             ITEM_DATA_MASK_CONTAINER
    int8[] mask3 = {  -1, -1,     -1,   -1,      0,  0,  0,  0,  -1, -1, -1, -1,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    // ITEM_DATA_MASK_MAP                                                                                              ITEM_DATA_MASK_MAP                                                                                                   ITEM_DATA_MASK_MAP
    int8[] mask4 = {  -1, -1,     -1,   -1,     -1, -1, -1, -1,   0,  0,  0,  0,   -1, -1,  -1, -1,  -1, -1,  -1, -1,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,     0,  0,  0,  0,   0,  0,  0,  0,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    SetItemDataMask( ITEM_DATA_MASK_CHOSEN, mask0 );
    SetItemDataMask( ITEM_DATA_MASK_CRITTER, mask1 );
    SetItemDataMask( ITEM_DATA_MASK_CRITTER_EXT, mask2 );
    SetItemDataMask( ITEM_DATA_MASK_CONTAINER, mask3 );
    SetItemDataMask( ITEM_DATA_MASK_MAP, mask4 );

    SetParameterChangeBehaviour( ST_BASE_CRTYPE, "_giveHair" );   // TabaK. Обработчик смены базового набора анимации для волос

    // call all functions added by _starter/START/AddStartCallback
    CallStartCallbacks();

    // old stuff
    qmap_load_all();
    WorldmapInit();
	
	// Inits
    InitCrimsonCaravans();
    InitTiles();
	
	SetGvar(GVAR_is_first_time, 0);

	GetVersionWorldSave( null );
	
	
    // Global Event Manager
    if( !manager_start() )
        return false;

	registerScriptingItems();
	getNpcNamesHolder().loadNpcNames();

	if (!SUI.Start()) 
		return false;
	
    return true;
}

void registerScriptingItems()
{
	registerTraps();
	registerMines();
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on world initialization.
// Parameter         Min    Max
// multiplier        1      50000
// year              1700   30000
// month             1      12
// day               1      31
// hour              0      23
// minute            0      59

void get_start_time( uint16& multiplier, uint16& year, uint16& month, uint16& day, uint16& hour, uint16& minute )
{
    multiplier = 8;
    year = 2248;
    month = 5;
    day = 14;
    hour = 1;
    minute = 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on finish server.
void finish()
{
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call every returned value, in milliseconds.
// Return next call in milliseconds or zero to disable loop.
/*
uint loop() // перенесено в loop.fos
{
    return manager_loop();
}
*/
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter attack another.
import uint GetAimApCost( int hitLocation ) from "combat";

import void hearshot( Critter& cr, ProtoItem& weapon, uint8 weaponMode ) from "rp_combat"; //Выстрелы на карте
void 		critter_attack( Critter& cr, Critter& target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo )
{
	if( cr.IsBusy() ) return;

	uint8 mode = weaponMode;
	
	if( _WeaponModeAim( mode ) == HIT_LOCATION_NONE && _WeaponAim( weapon, mode & 0x0F ) )
	{
		mode = ( weaponMode & 0x0F ) + ( cr.ParamBase[CR_AUTO_AIM] << 4 );
		if( cr.ParamBase[CR_AUTO_AIM] != HIT_LOCATION_NONE )
		{
			int delta = int( _WeaponApCost( weapon, weaponMode ) ) * 20;
			cr.StatBase[ ST_CURRENT_AP ] -= delta; //плюс 20% затрат ОД на прицельные атаки
		}
	}

	uint windupTime = GetProtoWindupTime(weapon, mode, cr);

 	if( windupTime != 0 )
	{
		uint[] vals = { cr.Id, target.Id, weapon.ProtoId, mode, 0, 0, 0 };
		if( valid( ammo ) )
			vals[4] = ammo.ProtoId;
		
		cr.SetDir( GetDirection( cr.HexX, cr.HexY, target.HexX, target.HexY ) );
		cr.Wait( windupTime );
		Item@ realWeapon = _CritGetItemHand(cr);
		cr.Action(ACTION_WINDUP, ACTION_FLAG_CHOSEN_INCLUSIVE << 12 | mode, valid(realWeapon) ? realWeapon : null );
		cr.SetAnims( COND_LIFE, 0, ANIM2_WINDUP );
		
		CreateTimeEvent( AFTER( REAL_MS( windupTime ) ), "e_DelayedAttack", vals, false );
	}
	else
	{
		CombatAttack( cr, target, weapon, mode, ammo, 0, 0 );
		cr.Wait(GetProtoTime(weapon, mode, cr));
	}
}

uint e_DelayedAttack(uint[]@ values)
{
	if( !valid( values ) || values.length() != 7 ) return 0;
	Critter@ cr = GetCritter(values[0]);
	Critter@ target = GetCritter(values[1]);
	ProtoItem@ weapon = GetProtoItem(values[2]);
	uint8 weaponMode = values[3];
	ProtoItem@ ammo = GetProtoItem(values[4]);
	uint hexX = values[5];
	uint hexY = values[6];
	
	if( !valid(cr) || !valid( weapon ) ) return 0;
	
	if( valid(target) && !cr.IsSee(target) && cr.Anim2Life == ANIM2_WINDUP )
	{
		cr.SetAnims(COND_LIFE, 0, ANIM2_IDLE);
		return 0;
	}
	
	Item@ realWeapon = _CritGetItemHand(cr);
	if( GetAttackDistantion( cr, realWeapon, weaponMode ) >= GetDistantion( cr.HexX, cr.HexY, valid(target) ? target.HexX : hexX, valid(target) ? target.HexY : hexY ) )
	{
		CombatAttack( cr, target, weapon, weaponMode, ammo, hexX, hexY );
		cr.Wait( GetProtoTime(weapon, weaponMode, cr) );
	}

	return 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter attack another.
void critter_attacked( Critter& cr, Critter& attacker )
{
    attacker.ParamBase[ LAST_ATTACKED ] = cr.Id;
	if( !manager_critter_attacked( cr, attacker ) )
		return;
		
    if( cr.IsPlayer() )
        return;                             // Diable player helping
    else
        AddAttackPlane( cr, 0, attacker );  // Answer on attack
    // if(cr.Timeout[TO_AGGRESSOR]>0) return;

    uint helpers = 0;
    uint maxHelpers = 10 - attacker.Stat[ ST_CHARISMA ];
    maxHelpers = CLAMP( maxHelpers, 2, 8 );

    Critter@[] critters;
    cr.GetCritters( true, FIND_LIFE_AND_KO | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        NpcPlane@ plane = critters[ i ].GetCurPlane();
        if( valid( plane ) && plane.Type == AI_PLANE_ATTACK && plane.Attack_TargId == attacker.Id )
        {
            helpers++;
            if( helpers >= maxHelpers )
                return;                    // No help needed
            @critters[ i ] = null;         // Exclude this critter
        }
    }

    int  crHpProc = cr.Stat[ ST_CURRENT_HP ] * 100 / cr.Stat[ ST_MAX_LIFE ];
    uint teamId = cr.Stat[ ST_TEAM_ID ];
    uint attackerTeamId = attacker.Stat[ ST_TEAM_ID ];
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        Critter@ someCr = critters[ i ];
        if( not valid( someCr ) )
            continue;                           // Skip excluded

        uint someCrTeamId = someCr.Stat[ ST_TEAM_ID ];
        if( attackerTeamId == someCrTeamId )
            continue;                                         // No attack temmate

        int teamParity = TEAM_PARITY( someCrTeamId, teamId ); // From -> To
        switch( teamParity )
        {
        case Ignore:
            continue;
        case Anyway:
            break;
        case NotBusy:
            if( someCr.IsCurPlane( AI_PLANE_ATTACK ) )
                continue;
            break;
        case HpLess10:
            if( crHpProc >= 10 )
                continue;
            break;
        case HpLess30:
            if( crHpProc >= 30 )
                continue;
            break;
        case HpLess50:
            if( crHpProc >= 50 )
                continue;
            break;
        case IfDead:
            if( not cr.IsDead() )
                continue;
            break;
        case GoodPerson:
            if( attacker.IsNpc() || cr.Stat[ ST_CHARISMA ] < 5 || cr.Stat[ ST_KARMA ] < 0 )
                continue;
            break;
        default:
            continue;
        }

        AddAttackPlane( someCr, 0, attacker );
        helpers++;
        if( helpers >= maxHelpers )
            break;                             // Enough
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter steal another.
bool critter_stealing( Critter& cr, Critter& thief, Item& item, uint count )
{
	if(cr.IsKnockout() || cr.Param[ST_CURRENT_HP] <= 0){
		return true;
	}
	
    if( cr.StatBase[ST_FOLLOW_CRIT] == int( thief.Id ) )
		return true;
	
	if( cr.Param[ HANDCUFFS ] != 0 )
        return true;                            // TabaK. Удачное воровство в наручниках.

    thief.TimeoutBase[ TO_AGGRESSOR ] = __FullSecond + REAL_MINUTE( 1 );

    if( cr.IsDead() || cr.Timeout[ TO_BATTLE ] > 0 || thief.Timeout[ TO_BATTLE ] > 0 )
    {
        thief.StatBase[ ST_LAST_STEAL_CR_ID ] = 0;
        thief.StatBase[ ST_STEAL_COUNT ] = 0;
        return false;
    }

    if( cr.Mode[ MODE_NO_PVP ] != 0 || thief.Mode[ MODE_NO_PVP ] != 0 )
    {
        thief.Say( SAY_NETMSG, "No PvP." );
        return false;
    }

    if( cr.IsKnockout() )
    {
        Item@[] items;
        Item@[] items0;
		Item@[] items1;
		Item@[] items2;
		Item@[] items3;
		
        uint itemscount = cr.GetItems( SLOT_HAND1, items );
        uint itemscount0 = cr.GetItems( SLOT_HAND2, items0 );
		uint itemscount1 = cr.GetItems( SLOT_HEAD, items1 );
		uint itemscount2 = cr.GetItems( SLOT_BACK, items2 );
		uint itemscount3 = cr.GetItems( SLOT_MISC, items3 );
		
        if( itemscount > 0 )
        {
            if( items[ 0 ].GetProtoId() != PID_HANDCUFFS && items[ 0 ].GetProtoId() != PID_ROPE_USED ) {
                cr.MoveItem( items[ 0 ].Id, itemscount, SLOT_INV );
			}
        }
		
        if( itemscount0 > 0 )
        {
            if( items0[ 0 ].GetProtoId() != PID_HANDCUFFS && items[ 0 ].GetProtoId() != PID_ROPE_USED ) {
                cr.MoveItem( items0[ 0 ].Id, itemscount0, SLOT_INV );
			}
        }
		
		if( itemscount1 > 0 )
        {
            if( items1[ 0 ].GetProtoId() != PID_COLLAR ) {
                cr.MoveItem( items1[ 0 ].Id, itemscount1, SLOT_INV );
			}
        }
		
		if( itemscount2 > 0 )
		{	 
			cr.MoveItem( items2[ 0 ].Id, itemscount2, SLOT_INV );
		}
		
		if( itemscount3 > 0 )
		{	 
			cr.MoveItem( items3[ 0 ].Id, itemscount3, SLOT_INV );
		}

        return true;
    }             // q3: Удачное воровство у нокаутированных.

    int dir1 = cr.Dir;
    int dir2 = thief.Dir;
    int kDir = MAX( dir1, dir2 ) - MIN( dir1, dir2 );
    if( kDir > 3 )
        kDir = 6 - kDir;

    int steal = thief.Skill[ SK_STEAL ];
    if( steal <= 0 )
        steal = 1;
    int size = item.Proto.Volume;
    if( size <= 0 )
        size = 1;

    // Perk pickpocket, ignore size and facing
    // if( thief.Perk[ PE_PICKPOCKET ] != 0 )
    // {
        // kDir = 0;
        // size = 1;
    // }

    // Count modifier
    int kCount = count / steal;
    if( kCount <= 0 )
        kCount = 1;

    // Check time of stealing
    uint lastStealCrId = thief.Stat[ ST_LAST_STEAL_CR_ID ];
    uint stealCount = thief.Stat[ ST_STEAL_COUNT ];
    if( lastStealCrId == cr.Id && thief.Timeout[ TO_STEALING ] > 0 )
        steal -= steal * stealCount * 9 / 100;

    // Calc
    int  k = ( steal - kDir * 10 ) / ( size * kCount );
    k = CLAMP( k, 5, 95 );
    bool success = !( Random( 1, 100 ) - (cr.Stat [ST_LUCK]-5)*5 > k );


    //if( thief.Perk[ PE_THIEF ] == 0 && item.GetProtoId() != PID_BOTTLE_CAPS && item.GetProtoId() != PID_BOTTLE_CAPS && thief.GetMap().GetLocation().GetProtoId() <= 6 )
    if( item.GetProtoId() != PID_BOTTLE_CAPS && item.GetProtoId() != PID_BOTTLE_CAPS && thief.GetMap().GetLocation().GetProtoId() <= 6 )
        success = false;

    if( isGM( thief ) )
        success = true;

    if( success )
    {
        Log_Steal( thief, cr.Id, item.GetProtoId(), 0, null, null );
        // Add experience     10,30,60,100,150,210,280,360,450,550,660,780
        const int[] stealExp = { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120 };

        if( lastStealCrId == cr.Id && thief.Timeout[ TO_STEALING ] > 0 )
        {
            stealCount++;
            if( stealCount > 11 )
                stealCount = 11;
            thief.StatBase[ ST_STEAL_COUNT ] = stealCount;
        }
        else
        {
            thief.StatBase[ ST_LAST_STEAL_CR_ID ] = cr.Id;
            thief.StatBase[ ST_STEAL_COUNT ] = 0;
        }

        if( !isGM( thief ) )
            thief.TimeoutBase[ TO_STEALING ] = STEAL_TIMEOUT( thief );
        if( cr.IsNpc() )
        {
            GameVar@ stealExpCount = ::GetUnicumVar( UVAR_steal_exp_count, cr.Id, thief.Id );
            if( stealExpCount < 12 )
            {
                // thief.StatBase[ST_EXPERIENCE]+=stealExp[stealCount];
                thief.AddScore( SCORE_THIEF, 1 );
            }
            stealExpCount = stealExpCount + 1;
        }
    }
    else
    {
        thief.Action( ACTION_PICK_CRITTER, 3, null );
        thief.StatBase[ ST_LAST_STEAL_CR_ID ] = 0;
        thief.StatBase[ ST_STEAL_COUNT ] = 0;

        if( cr.IsNpc() )
        {
            int thiefHp = thief.Stat[ ST_CURRENT_HP ];
			AddAttackPlane( cr, 0, thief, thiefHp< 10 || Random( 1, 10 ) > cr.Stat[ ST_LUCK ] + 4 || cr.Stat[ ST_CHARISMA ] < 3 ? __DeadHitPoints : Random( thiefHp / 4, thiefHp / 2 ) );
        }
    }

    return success;
}

/*bool subWater( Critter& cr, Item@ item ) //АРТЕФАКТ
{
	Item@ water = valid( item ) ? @item : cr.GetItem( PID_BOTTLE_FULL, -1 );
	if( !valid(water) )
		@water = cr.GetItem( PID_GLASS_BOTTLE_FULL, -1 );
	
	if( !valid(water) )
		return false;
	
	if( water.GetProtoId() == PID_BOTTLE_FULL )
		cr.AddItem( PID_BOTTLE_EMPTY, 1 );
	else
		cr.AddItem( PID_BOTTLE_GLASS, 1 );

	_SubItem( water, 1 );
	return true;
}*/

import bool collectWater( Critter& cr, Item@ bottle ) from "adv_items";

//import bool critter_use_item( Critter& cr, Item& item, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen, uint param ) from "main";
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter use item.
bool critter_use_item( Critter& cr, Item& item, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen, uint param )
{
	string exception_catcher = cr.Id + "# in " + (valid(cr.GetMap())?"@"+cr.GetMap().Id:"global") + " used "
		+ (valid(item)?item.Id:0) + ":" + (valid(item)?item.GetProtoId():0) + " on [" 
		+ (valid(targetCr)?targetCr.Id:0) + ", " 
		+ (valid(targetItem)?targetItem.Id:0) + ":" + (valid(targetItem)?targetItem.GetProtoId():0) + ", " 
		+ (valid(targetScen)?targetScen.ProtoId:0) + "] with param " + param + ".";
	//DebugLog( exception_catcher );
	
	if( cr.Param[ QST_GAMEMODE ] == GAME_TEST )
		cr.Say( SAY_NETMSG, exception_catcher );

    bool   isPlayer = cr.IsPlayer();
    uint16 pid = item.GetProtoId();
    bool   useOnSelf = ( not valid( targetCr ) && not valid( targetItem ) && not valid( targetScen ) );
	
	cr.Wait(GetProtoTime(item.Proto, 0, cr));
	Map@ map = cr.GetMap();
	
	string action_info = crInfo( cr ) + " применяет " + itemDesc( item ) + " на ";
	if( useOnSelf )
		action_info += "себя";
	else
	{
		if( valid( targetCr ) )
			action_info += crInfo( targetCr );

		if( valid( targetItem ) )
			action_info += itemDesc( targetItem );
		
		if( valid( targetScen ) )
			action_info += "сценери #" + targetScen.ProtoId;
	}
	SayLog( cr, action_info + "." );

	if( PrepareScavenging( cr, item, targetItem ) ) { return true; }
	
	if( PrepareMining( cr, item, targetItem ) ) { return true; }
	
	if( PrepareChopping( cr, item, targetItem ) ) { return true; }
	
	if( SlotMachineCheck( cr, item, targetItem ) ) { return true; }

	if( FireCheck( cr, item, targetItem ) ) { return true; }
	
	if( UseItemOnStill( cr, item, targetItem ) ) { return true; }

	if( valid( targetScen ) && ( pid == PID_BOTTLE_EMPTY || pid == PID_BOTTLE_GLASS ) )
	{
		uint scenPID = targetScen.ProtoId;
		if( scenPID >= 16980 && scenPID <= 16994 )
			return collectWater( cr, item );
	}
	
	if( useOnSelf )
	{
		if( cr.ParamBase[CR_TEMP] > 0 )
		{
			if( pid == PID_BOTTLE_FULL || pid == PID_GLASS_BOTTLE_FULL )
			{
				cr.ParamBase[CR_TEMP] = 0;
				cr.Say( SAY_EMOTE_ON_HEAD, "Тушит себя водой" );
				cr.DeleteItem (pid, 1);
				if( pid == PID_BOTTLE_FULL )
					cr.AddItem( PID_BOTTLE_EMPTY, 1 );
				else
					cr.AddItem( PID_BOTTLE_GLASS, 1 );
				return true;
			}
			else
			{
				cr.Say( SAY_NETMSG, "|0xFFFF00 Используйте воду, что бы потушить себя." );
			}
		}
	}
	else
	{
		if( valid( targetCr ) && targetCr.ParamBase[CR_TEMP] > 0 )
		{
			if( pid == PID_BOTTLE_FULL || pid == PID_GLASS_BOTTLE_FULL ) 
			{
				cr.Say( SAY_EMOTE_ON_HEAD, "Тушит водой" );
				
				targetCr.ParamBase[CR_TEMP] = 0;
				targetCr.Say( SAY_NETMSG, "|0xFFFF00 Вас потушили." );
				cr.DeleteItem (pid, 1);
				if( pid == PID_BOTTLE_FULL )
					cr.AddItem( PID_BOTTLE_EMPTY, 1 );
				else
					cr.AddItem( PID_BOTTLE_GLASS, 1 );
				return true;
			}
			else
			{
				cr.Say( SAY_NETMSG, "|0xFFFF00 Используйте воду, что бы потушить цель." );
			}
		}
	}
	
	if( valid( targetCr ) && targetCr.StatBase[ ST_BODY_TYPE ] == BT_BRAHMIN && BrahminPetting( cr, item, targetCr ) )
		return true;



	// ================================================== Мио ==================================================

	if( valid( targetScen ) )
	{
		uint[] scenToiletList = { 2616, 2618, 2690, 3754 }; // Унитазы.
		if( scenToiletList.find( targetScen.ProtoId ) > -1 )
		{
			uint[] itemToiletList = // Предметы, которые можно сдёрнуть.
			{
				PID_SHIT_SMALL, PID_SHIT_BIG, PID_SHIT_HUGE, // Дерьмо.
				PID_RPSTUFF2, PID_DOLLAR_100, PID_HOLODISK, PID_DOLLAR_20, PID_DOLLAR_5, // Бумаги
				PID_KOSYAK, PID_MENTATS, PID_BUFFOUT, PID_PSYCHO, PID_JET // Наркотики
			};

			if( itemToiletList.find( item.GetProtoId() ) > -1 ) 
			{ 
			LordOfDestruction( cr, item, 1 ); 
			return true; 
			}
		}
	}

	if( pid == PID_DICE )					{ DiceUse( cr, item ); return true; }
	if( pid == PID_LOADED_DICE )			{ DiceUse( cr, item ); return true; }
	if( pid == PID_DECK_OF_CARDS )			{ CardsUse( cr, item ); return true; }
	if( pid == PID_MARKED_DECK_OF_CARDS )	{ CardsUse( cr, item ); return true; }

	if( pid == PID_BOTTLE_CAPS )			{ CoinUse( cr, item ); return true; }

	if( pid == PID_GUNSMITH )				{ ScouringStick( cr, item ); return true; }
	if( pid == PID_MapSolt )				{ ShowTheWay( cr, targetCr ); return true; }

	if( pid == PID_RPSTUFF1 ||
		pid == PID_RPSTUFF2 ||
		pid == PID_RPSTUFF3 ||
		pid == PID_RPSTUFF4 ||
		pid == PID_WEDRING_F ||
		pid == PID_WEDRING_M )				{ DescriptionUse( cr, item ); return true; }

	// ================================================== --- ==================================================



	uint[] soap_pids = { PID_ITSOAP01_PRT, PID_FPSHL6_PRT, PID_ITSOAP01, PID_FPSHL6 };
	if( soap_pids.find( pid ) != -1 )
	{
		Critter@ target = useOnSelf ? @cr : @targetCr;
		if( valid( target ) )
		{
			Cleaning( cr, target, pid, 0 );
			return true;
		}
	}
		
	if( valid( targetItem) && SetTrapOnItem( cr, item, targetItem ) )
		return true;
	
    if( pid == PID_SHOVEL )
	{
		uint[] ashes = { PID_ASHES_1, PID_ASHES_2, PID_ASHES_3 };
		if( valid( targetItem ) && ashes.find( targetItem.GetProtoId() ) != -1 )
		{
			cr.Say( SAY_EMOTE_ON_HEAD, "Убирает золу" );
			DeleteItem(targetItem);
			return true;
		}

		bool isBones = valid(targetItem) && targetItem.GetProtoId() >= PID_BLOOD_BONES_1 && targetItem.GetProtoId() <= PID_BLOOD_BONES_3;
		bool isBody = valid( targetCr ) && targetCr.IsDead();
		if( isBones || isBody )
		{
			cr.Say( SAY_EMOTE_ON_HEAD, "Убирает останки" );
			cr.Animate( 0, ANIM2_PICKUP, null, false, true );
			if( isBones )
			{
				targetItem.Val0 += Random( 1, 3 );
				if( targetItem.Val0 > 10 )
					DeleteItem( targetItem );
			}
			if( isBody )
			{
				if( cr.Stat[ ST_STRENGTH ] * 10 - targetCr.Stat[ ST_CURRENT_HP ] < targetCr.Stat[ ST_MAX_LIFE ] )
					targetCr.StatBase[ ST_CURRENT_HP ] -= Random( 1, cr.Stat[ ST_STRENGTH ] * 2 );
				else 
					DeleteNpc( targetCr );
			}
			return true;
		}
	}
	
	if( pid == PID_CRAFT_L_RAGS && valid(targetItem) && targetItem.GetProtoId() >= PID_BLOOD_SMALL_1 && targetItem.GetProtoId() <= PID_BLOOD_BIG_3 )
	{
		cr.Say( SAY_EMOTE_ON_HEAD, "Вытирает кровь тряпкой" );
		cr.Animate( 0, ANIM2_PICKUP, null, false, true );
		targetItem.Val0 -= Random( 1, 3 );
		if( targetItem.Val0 < 1 )
			DeleteItem( targetItem );
		return true;
	}
	
	if( pid == PID_SHIV ) 
	{
		if( valid( targetItem ) ) 
		{
			cr.Say( SAY_NETMSG, "|0xFFFF00 Что в этом предмете особенного?" );
			cr.StatBase[ ST_LAST_DOOR_ID ] = targetItem.Id;
			cr.StatBase[ ST_LAST_CONT_ID ] = targetItem.Accessory;
			ShowInputBoxScreen( cr, "main@unsafe_MakeDescLex#Описание:", 0, INPUTBOX_CLOSE_ON_ENTER );
			return true;
		}
		if( valid( targetCr ) ) 
		{
			cr.Say( SAY_NETMSG, "|0xFFFF00 Вам необходимо больше инструментов для того, что бы наколоть татуху." );
			return true;
		}
		cr.Say( SAY_NETMSG, "|0xFFFF00 Похоже, вы без понятия, что с этим можно делать." );
		return true;
	}

	if( !(targetItem is null) && targetItem.GetType() == ITEM_TYPE_DOOR )
    {
        cr.StatBase[ ST_LAST_DOOR_ID ] = targetItem.Id;
    }
	
    if( pid == PID_HOMEBREW )
	{
		drinkHomebrew( cr, item );
		return true;
	}
		
	if( pid == PID_BANDAGE || pid == PID_CRAFT_L_RAGS )
    {
		bool isBandage = ( pid == PID_BANDAGE );

		Critter@ victim = ( useOnSelf ? @cr : @targetCr );
		victim.StatBase[ ST_BLEED ] /= ( isBandage ? 6 : 4 );

		cr.Say( SAY_EMOTE_ON_HEAD, "перебинтовывает" + ( useOnSelf ? "ся" : "" ) );
        cr.DeleteItem( ( isBandage ? PID_BANDAGE : PID_CRAFT_L_RAGS ), 1 );
		map.PlaySound( "bandage.ogg", cr.HexX, cr.HexY, 2 );
        return true;
    }

    if( valid( targetCr ) && targetCr.StatBase[ HANDCUFFS ] != 0 )
    {
        if( unlock( cr, targetCr, pid ) )
            return true;
    }

	if( useOnSelf && cr.StatBase[ HANDCUFFS ] != 0 )
    {
		if( unlock( cr, cr, pid ) )
            return true;
    }

    if( cr.IsPlayer() && useOnSelf && item.GetType() == ITEM_TYPE_CONTAINER )
    {
        cr.ParamBase[ ST_LAST_CONT_ID ] = item.Id;
        cr.ShowContainer( null, item, TRANSFER_SELF_CONT );
        return true;
    }
	
    if( valid( targetCr ) && targetCr.Param[ QST_GAMEMODE ] == GAME_ARCADE && item.GetProtoId() == PID_ROPE && ( targetCr.IsKnockout() || targetCr.IsDead() ) )
    {
        Map@   map = cr.GetMap();
        uint16 mapPid = map.GetProtoId();
        if( mapPid == 18 || mapPid == 19 )
        {
            Map@   prison = GetMapByPid( 19, 0 );
            bool   noVacancy = true;
            uint8  counter = 0;
            uint8  cellIndex = 0;
            uint16 X = 0, Y = 0;
            while( counter < 18 )
            {
                if( prison.GetData( counter ) == 0 )
                {
                    cellIndex = counter;
                    noVacancy = false;
                    counter = 18;
                }
                counter++;
            }
            if( !noVacancy )
            {
                prison.GetEntireCoords( 113, cellIndex, X, Y );
                targetCr.TransitToMap( prison.Id, X, Y, Random( 0, 5 ) );
                prison.SetData( cellIndex, targetCr.Id );
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, 12740 );
                targetCr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, 12742 );
                if( targetCr.IsKnockout() )
                    DeleteItem( item );
            }
            else
            {
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, 12741 );
            }
            return true;
        }
        return false;
    }

    if( pid == PID_KEY_BUNCH && !(targetItem is null) && ( targetItem.GetType() == ITEM_TYPE_DOOR || targetItem.GetType() == ITEM_TYPE_CONTAINER ) )
    {
		Item@[] keys;
		uint count = item.GetItems( uint( -1 ), keys );
		map.PlaySound( "keys.ogg", cr.HexX, cr.HexY, 2 );

		for( uint i = 0; i < count; i++ )
		{
			if( keys[i].LockerId == targetItem.LockerId )
			{
				UseItemOnLocker( cr, targetItem, keys[i] );
				return true;
			}
		}
		return false;
    }

    // ///////////////////////////////////////TabaK/////////////////////////////////////////////
    // ////////////////////////////////////////Яд///////////////////////////////////////////////

    if( useOnSelf && pid == PID_HYPO_POISON && cr.Stat[ ST_BODY_TYPE ] != BT_ROBOT )
    {
		if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, 12909 );
			AffectParalysis( cr, 50 );
			cr.DeleteItem( PID_HYPO_POISON, 1 );
		}
        return true;
    }
    if( valid( targetCr ) && pid == PID_HYPO_POISON && targetCr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT )
    {
        targetCr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, 12910 );
        AffectParalysis( targetCr, 50 );
        cr.DeleteItem( PID_HYPO_POISON, 1 );
        return true;
    }

    // ///////////////////////////////////Антидот/////////////////////////////////////////////
    if( useOnSelf && pid == PID_ANTIDOTE_2 )
    {
        if( cr.Param[ ST_PARALYSIS_LEVEL ] != 0 || cr.Param[ ST_POISONING_LEVEL ] != 0 )
        {
            DropPoison( cr );
            DropParalysis( cr, 50 );
            cr.DeleteItem( PID_ANTIDOTE_2, 1 );
			cr.AddItem( PID_HYPODERMIC_NEEDLE, 1 );
            return true;
        }
        else
        {
            cr.DeleteItem( PID_ANTIDOTE_2, 1 );
			cr.AddItem( PID_HYPODERMIC_NEEDLE, 1 );
            return false;
        }
    }

    if( valid( targetCr ) && pid == PID_ANTIDOTE_2 )
    {
        if( targetCr.Param[ ST_PARALYSIS_LEVEL ] != 0 || targetCr.Param[ ST_POISONING_LEVEL ] != 0 )
        {
            DropPoison( targetCr );
            DropParalysis( targetCr, 50 );
            cr.DeleteItem( PID_ANTIDOTE_2, 1 );
			cr.AddItem( PID_HYPODERMIC_NEEDLE, 1 );
            return true;
        }
        else
        {
            cr.DeleteItem( PID_ANTIDOTE_2, 1 );
			cr.AddItem( PID_HYPODERMIC_NEEDLE, 1 );
            return false;
        }

    }
    // /////////////////////////////////////////////////////////////////////////////////////////////


    if( pid == PID_SCISSORS )
    {
        if( useOnSelf )
            HairCut( cr, cr );
        else
            HairCut( cr, targetCr );
        return true;
    }

    if(( pid == PID_CUTTHROAT ) || ( pid == PID_RAZOR ))
	{
        Shave( cr, useOnSelf ? @cr : @targetCr );
        return true;
    }

	if( CutCheck( cr, item, useOnSelf ? @cr : @targetCr ) ) return true;

    // Radio
    if( FLAG( item.Flags, ITEM_RADIO ) && useOnSelf )
    {
        if( isPlayer )
            EditRadioSettings( cr, item );
        return true;
    }

    // Book reading
    if( useOnSelf && IsReadableBook( pid ) )
    {
        TryReadBook( cr, item );
        return true;
    }

    // Explosion
    if( OnUseExplode( cr, item, targetCr, targetItem, targetScen, param ) )
        return true;

    // Cars
    if( valid( targetItem ) && targetItem.GetType() == ITEM_TYPE_CAR && UseItemOnCar( cr, targetItem, item ) )
        return true;

    // Drugs
    if( item.GetType() == ITEM_TYPE_DRUG || item.GetType() == ITEM_TYPE_FOOD )
    {
    	if ((useOnSelf && cr.StatBase [ST_BODY_TYPE] == BT_ROBOT) || ( @targetCr != null && targetCr.StatBase [ST_BODY_TYPE] == BT_ROBOT)) return false;
        if( pid == 40 )
            ChangeCritterSpeed( @targetCr != null ? targetCr : cr );                 // pm added

        uint8  hungerBonus = item.Proto.Food_Restore;
        uint8  thristBonus = item.Proto.Food_Thrist;

        switch(pid)
           {
				case PID_FORSAGE_GUM:
				case PID_CARAMEL2:
				case PID_ITCANDY:
					cr.Say( SAY_EMOTE_ON_HEAD, "Ест конфетку" );
					cr.StatBase[ST_EXPERIENCE] += Random( 100, 500 );
				break;
                case PID_STIMPAK: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10310 ); break;
                case PID_RADAWAY: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10311	); break;
                case PID_ANTIDOTE: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10312 ); break;
                case PID_MENTATS: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10313 ); break;
                case 71: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10314 ); break;
                case 81: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10315 ); break;
                case 87: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10316 ); break;
                case 103: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10317 ); break;
                case 106: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10318 ); break;
                case 109: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10319 ); break;
                case 110: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10320 ); break;
                case 124: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10311 ); break;
                case 125: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10312 ); break;
                case 144: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10313 ); break;
                case 259: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10314 ); break;
                case 260: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10315 ); break;
                case 273: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10316 ); break;
                case 310: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10317 ); break;
                case 311: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10318 ); break;
                case 378: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10319 ); break;
                case 469: cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10330 ); break;
                case PID_MEAT_JERKY : cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10331 ); break;
                case PID_MEAT : cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10331 ); break;
                case PID_RAD_MEAT : cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, 10331 ); break;
                default : break;
           }

       if( useOnSelf )
        {
            cr.StatBase[ ST_HUNGER ] += hungerBonus * SATURATION_SIMPLIFIER;
            cr.StatBase[ ST_THIRST ] += thristBonus * SATURATION_SIMPLIFIER;
            //cr.StatBase[ ST_THIRST ] -= hungerBonus / 3;
            ProccessFood( cr, cr, item );
            UseDrug( cr, item );
            
            cr.Action( ACTION_USE_ITEM, 2, item );
        }
        else if( valid( targetCr ) )
        {
            targetCr.StatBase[ ST_HUNGER ] += hungerBonus * SATURATION_SIMPLIFIER;
            targetCr.StatBase[ ST_THIRST ] += thristBonus * SATURATION_SIMPLIFIER;
            //targetCr.StatBase[ ST_THIRST ] -= hungerBonus / 3;
            ProccessFood( cr, targetCr, item );
            UseDrugOn( cr, targetCr, item );
            
            cr.Action( ACTION_USE_ITEM, 1, item );
        }

        // cr.Say(SAY_EMOTE_ON_HEAD, drugUseString);
        // }
        // if(valid(targetCr)) { return true;}
        // else cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_USE_NOTHING);
/*
        // stimpack
        if( pid == PID_STIMPAK && cr.Stat[ST_BODY_TYPE] != BT_ROBOT)
        {
            if (useOnSelf) ItemStimpackUse( cr, item );
            else ItemStimpackUse (targetCr, item);
        }
        
        // hypo
        if (pid == PID_HYPO && cr.Stat[ ST_BODY_TYPE ] != BT_ROBOT ) 
		{
        	ItemHypoUse (cr, item);
    	}
        if (pid == PID_SUPER_STIMPAK && cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) {
        	ItemSupUse (cr, item);
    	}
*/
        return true;
    }
    
	if( pid == PID_OIL_LAMP ) //масляная лампа
	{
		if( item.Val1 == 0 && item.Val0 > 0 )
		{
			Item@ lighter = cr.GetItem( PID_LIGHTER, -1 );
			if( valid(lighter) ) 
			{
				cr.MoveItem( item.Id, item.GetCount(), SLOT_HAND1 );
				SETFLAG( item.Flags, ITEM_LIGHT );
				SETFLAG( item.Flags, ITEM_COLORIZE );
				SETFLAG( item.Flags, ITEM_COLORIZE_INV );
				item.Update();
				item.Val1 = 1;
				uint[] values = { item.Id };
				item.Val3 = CreateTimeEvent( AFTER( REAL_SECOND( 0 ) ), "e_DepleteOil", values, true );
				cr.Say( SAY_EMOTE , "Разжигает фонарь" );
				map.PlaySound( "WAI1XXX2.ACM", cr.HexX, cr.HexY, 2 );
				return true;
			}
			else 
			{
				cr.Say( SAY_NETMSG , "|0xFFFF00 Для розжига фонаря нужна зажигалка!" );
			}
			return true;
		}
		else if( item.Val0 == 0 )
		{
			cr.Say( SAY_NETMSG , "|0xFFFF00 В фонаре нет масла." );
			return true;
		}
		else
		{			
			UNSETFLAG( item.Flags, ITEM_LIGHT );
			UNSETFLAG( item.Flags, ITEM_COLORIZE );
			UNSETFLAG( item.Flags, ITEM_COLORIZE_INV );
			item.Update();
			item.Val1 = 0;
			EraseTimeEvent( item.Val3 );
			item.Val3 = 0;
			
			cr.Say( SAY_EMOTE , "Гасит фонарь" );
			map.PlaySound( "STEAM1.ACM", cr.HexX, cr.HexY, 2 );
		}
		return true;
	}
	
	if( pid == PID_FLASHLIGHT_ON ) //Фонарик выкл.
    {
		flashlight_off( cr, item );
        return true;
    }

    if( pid == PID_FLASHLIGHT_OFF && item.Val0 > 0 ) //Фонарик вкл.
    {		
		cr.MoveItem( item.Id, item.GetCount(), SLOT_INV );		
		Item@ fl_on = cr.AddItem( PID_FLASHLIGHT_ON, 1  );
		fl_on.Val0 = item.Val0;
		_SubItem( item, 1 );
		if( valid( fl_on ) )
		{
			cr.MoveItem( fl_on.Id, fl_on.GetCount(), SLOT_HAND1 );
			uint[] values = { fl_on.Id };
			cr.RefreshVisible();
			if( valid( map ) ) {
				map.PlaySound( "BUTIN2.ACM", cr.HexX, cr.HexY, 1 );
			}
			fl_on.Val3 = CreateTimeEvent( AFTER( REAL_SECOND( 0 ) ), "e_DepleteBattery", values, true );
		}
        return true;
    }
	
	if( pid == PID_ACTIVE_FLARE ) //Фонарик выкл.
    {
        _SubItem( item, 1 );
		map.PlaySound( "BUTIN4.ACM", cr.HexX, cr.HexY, 1 );
        return true;
    }
    if( pid == PID_FLARE ) //Фонарик вкл.
    {
		cr.MoveItem( item.Id, item.GetCount(), SLOT_INV );
		_SubItem( item, 1 );
		Item@ flare = cr.AddItem( PID_ACTIVE_FLARE, 1  );
		
		if( valid( flare ) )
		{
			cr.MoveItem( flare.Id, flare.GetCount(), SLOT_HAND1 );
		}
		
		map.PlaySound( "flare.ogg", cr.HexX, cr.HexY, 3 );
		uint[] values = {flare.Id};
		CreateTimeEvent( __FullSecond + REAL_MINUTE( 60 ), "e_FlareBurn", values, true );	
	}

	    // Magic ball
    if( pid == PID_MAGIC_8_BALL )
    {
        cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, Random( 1, 2 ) == 1 ? STR_MAGIC_BALL_YES : STR_MAGIC_BALL_NO );
        return true;
    }

    // Cosmetic
    if( pid == PID_COSMETIC_CASE && cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
    {
        cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_COSMETIC_USE );
        return true;
    }
	
	// OilLamp charging
	if( pid == PID_PLANT_OIL && valid( targetItem ) && targetItem.GetProtoId() == PID_OIL_LAMP )
	{
		map.PlaySound( "ROBE.ACM", cr.HexX, cr.HexY, 1 );
		targetItem.Val0 = 60;
		_SubItem( item, 1 );
		return true;
	}
	
	// Flashlight charging
	if( ( pid == PID_SMALL_ENERGY_CELL || pid == PID_CUENCELL_LOW ) && valid( targetItem ) && ( targetItem.GetProtoId() == PID_FLASHLIGHT_OFF || targetItem.GetProtoId() == PID_FLASHLIGHT_ON ) )
	{
		pid == PID_SMALL_ENERGY_CELL ? targetItem.Val0 = 100 : targetItem.Val0 = 50;
		cr.Say( SAY_NETMSG , "|0xFFFF00 Вы заменили батарею фонарика" );
		map.PlaySound( "WRJ1XXX1.ACM", cr.HexX, cr.HexY, 1 );
		_SubItem( item, 1 );
		return true;
	}
	
	// Костры
	if( ( ( pid == PID_LIGHTER || pid == PID_FLINT ) && valid( targetItem ) && targetItem.GetProtoId() == PID_CHOPPED_FIREWOOD ) )
	{
		return Ignite( cr, item, targetItem );
	}
	
	if ( (pid == PID_LIGHTER) && ( _CritCountItem( cr, PID_CRAFT_L_RAGS  ) > 0) && valid(targetItem) && targetItem.GetProtoId() == PID_COAL)
	{
		cr.DeleteItem (PID_CRAFT_L_RAGS, 1);
		return e_Repair( targetItem, cr, item );
	}
	
	if ( ( pid == PID_LIGHTER ) && valid( targetItem ) && targetItem.GetProtoId() == PID_COAL )
	{ cr.Say( SAY_NETMSG , "|0xFF0000 Вам необходимы зажигалка и кусок ткани для розжига костра из этого" ); }
	
	// Пачка сигарет
	if( pid == PID_CIGARETTES )
	{
		cr.Say( SAY_EMOTE, "Вскрывает пачку сигарет" );
		map.PlaySound( "arm_fishing_rod.ogg", cr.HexX, cr.HexY, 2 );
		_SubItem( item, 1 );
		cr.AddItem( PID_CIGARETTES_PRT, 1 );
		return true;
	}
		
	if( pid == PID_CIGARETTES_PRT )
	{
		if( item.Val0 < 1 )
		{
			cr.Say( SAY_NETMSG, "|0xFFFF00 В пачке больше не осталось сигарет." );
			_SubItem( item, 1 );
			return true;
		}
		cr.Say( SAY_EMOTE, "Достаёт сигарету из пачки" );
		map.PlaySound( "arm_fishing_rod.ogg", cr.HexX, cr.HexY, 2 );
		cr.AddItem( PID_CIGARETTE, 1 );
		item.Val0--;
		item.Update();
		return true;
	}
	
    // Cigarettes smoking
    if( pid == PID_CIGARETTE )
    {
		Item@ respirator = _CritGetItemHandExt( cr );
		if( !(respirator is null) && respirator.GetProtoId() == PID_RESPIRATOR )
		{
			cr.Say( SAY_NETMSG, "|0xFF0000 Вы не можете курить через респиратор." );
			return true;
		}
		if( item.CritSlot != SLOT_HAND1 )
		
		{
		cr.Say(SAY_NETMSG, "|0xFFFF00 Возьмите сигарету в руку, чтобы закурить.");
			return true;
		}
		
		if( ( _CritCountItem( cr, PID_LIGHTER ) > 0 || _CritCountItem( cr, PID_FIREPLACE_TOKEN ) > 0 ) ) 
		{
			cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_CIGARETTES_SMOKE );
						
			_SubItem( item, 1 );
			cr.StatBase[ ST_DYSPNEA ] -= Random( 0, 5 );
			cr.StatBase[ ST_HUNGER ] -= Random( 0, 1 );
			cr.StatBase[ ST_THIRST ] -= Random( 0, 1 );
			
			int time = cr.Timeout[ TO_TIREDNESS ];
			if( time > 0 )
			{
				time = CLAMP( time - REAL_SECOND( Random( 15, 30 ) ), 0, time );
				cr.TimeoutBase[ TO_TIREDNESS ] = __FullSecond + time;
			}
				if( Random( 0, 1 ) > 0 )
					map.PlaySound( "smoking.ogg", cr.HexX, cr.HexY, 1 );
				else
					map.PlaySound( "drugs2.wav", cr.HexX, cr.HexY,  1 );
		}
		else
			cr.Say( SAY_NETMSG, "|0xFF0000 Вам нужен источник огня, что бы прикурить." );
        return true;
    }
	
	    // Cigar smoking
	
	if( pid == PID_PREWAR_CIGAR1_PRT || pid == PID_PREWAR_CIGAR2_PRT || pid == PID_PREWAR_CIGAR1 || pid == PID_PREWAR_CIGAR2 )
	{
		if( item.CritSlot != SLOT_HAND1 )
		{
			cr.Say(SAY_NETMSG, "|0xFFFF00 Возьмите сигару в руку, чтобы раскурить.");
			return true;
		}
			if( ( _CritCountItem( cr, PID_LIGHTER ) < 1 ) ) 
				{ 
					cr.Say( SAY_NETMSG, "|0xFF0000 Вам нужна зажигалка, что бы прикурить." );
					return true;
				}
				else
				{
					if(  pid == PID_PREWAR_CIGAR1 || pid == PID_PREWAR_CIGAR2 )
					{
						cr.Say( SAY_EMOTE, "Раскуривает сигару" );
						cr.MoveItem( item.Id, item.GetCount(), SLOT_INV );
						_SubItem( item, 1 );
						Item@ okurok = cr.AddItem( ( pid == PID_PREWAR_CIGAR1 ) ? PID_PREWAR_CIGAR1_PRT : PID_PREWAR_CIGAR2_PRT, 1  );
							if(valid(okurok))
							{
								cr.MoveItem( okurok.Id, okurok.GetCount(), SLOT_HAND1 );
							}
					}
					else if(  pid == PID_PREWAR_CIGAR1_PRT || pid == PID_PREWAR_CIGAR2_PRT )
					{
						cr.Say( SAY_EMOTE, "Курит сигару" );
						item.Val0--;
						switch( item.Val0 )
						{
							case(8):
							item.PicInv = GetStrHash( "art\\inven\\misc\\cigar\\cigar_st2_inv.png" );
							break;
							case(7):
							item.PicInv = GetStrHash( "art\\inven\\misc\\cigar\\cigar_st3_inv.png" );
							break;
							case(6):
							item.PicInv = GetStrHash( "art\\inven\\misc\\cigar\\cigar_st4_inv.png" );
							break;
							case(5):
							item.PicInv = GetStrHash( "art\\inven\\misc\\cigar\\cigar_st5_inv.png" );
							break;
							case(4):
							item.PicInv = GetStrHash( "art\\inven\\misc\\cigar\\cigar_st6_inv.png" );
							break;
							case(3):
							item.PicInv = GetStrHash( "art\\inven\\misc\\cigar\\cigar_st7_inv.png" );
							break;							
							case(2):
							item.PicInv = GetStrHash( "art\\inven\\misc\\cigar\\cigar_st8_inv.png" );
							break;
							case(1):
							item.PicInv = GetStrHash( "art\\inven\\misc\\cigar\\cigar_st9_inv.png" );
							break;
						}
						item.Update();
						
						if( item.Val0 < 1 )
						{
							cr.Say( SAY_EMOTE, "Докурил сигару" );
							_SubItem( item, 1 );
						}
					}
					cr.StatBase[ ST_DYSPNEA ] -= Random( 0, 5 );
					cr.StatBase[ ST_THIRST ] -= Random( 0, 1 );
					int time = cr.Timeout[ TO_TIREDNESS ];
						if( time > 0 )
						{
							time = CLAMP( time - REAL_SECOND( Random( 15, 30 ) ), 0, time );
							cr.TimeoutBase[ TO_TIREDNESS ] = __FullSecond + time;
						}
					
					map.PlaySound( "smoking.ogg", cr.HexX, cr.HexY, 1 );
				}
		return true;
	}
	
	// Towels
	if( pid == PID_TOWEL || pid == PID_OLD_TOWEL )
	{
		if( pid == PID_TOWEL && useOnSelf )
		{
			cr.Say( SAY_EMOTE, "Вытирается полотенцем" );
			_SubItem( item, 1 );
			cr.AddItem(  PID_OLD_TOWEL, 1  );
		}			
		else if( pid == PID_OLD_TOWEL && useOnSelf )
		{
		cr.Say( SAY_EMOTE, "Вытирается грязным полотенцем" );
		cr.ParamBase[ CR_DIRTINESS ] = ( cr.ParamBase[ CR_DIRTINESS ] * 0.8 ) + 5;
		}
		else if( water_sources.find( targetScen.ProtoId ) != -1 )
		{
			cr.Say( SAY_EMOTE, "Моет полотенце" );
			map.PlaySound( "water_running.ogg", cr.HexX, cr.HexY, 5 );	
			_SubItem( item, 1 );
			cr.AddItem(  PID_TOWEL, 1  );
		}
	return true;
	}
	
    // Mutate
    if( pid == PID_MUTAGENIC_SYRUM )
    {
        cr.Say( SAY_EMOTE_ON_HEAD, "вкалывает сыворотку" );
        ApplyMutation( cr );
        cr.DeleteItem( PID_MUTAGENIC_SYRUM, 1 );
        return true;
    }

    // remove locker from door
/* //Убрал возможность вскрывать гермодвери ломом.
    if( ( pid == PID_CROWBAR || pid == PID_IRON_ROD ) && !(targetItem is null) && targetItem.GetType() == ITEM_TYPE_DOOR && IsDoorAutomatic( targetItem.GetProtoId() ) )
    {
        if( targetItem.Val6 == 0 )
        {
            if( cr.Stat[ ST_STRENGTH ] >= 4 )
            {
                if( Random( 1, 100 ) + (cr.Stat [ST_LUCK]-5)*5 > 45 )
                {
                    if( !FLAG( targetItem.LockerCondition, LOCKER_ISOPEN ) )
                        targetItem.LockerOpen();
                    else
                        cr.Say( SAY_NETMSG, "Закрыть дверь ломом не выйдет." );
                }
                else
                {
                    cr.Say( SAY_NETMSG, "Дверь не поддалась." );
                }
            }
            else
            {
                cr.Say( SAY_NETMSG, "У вас недостаточно сил для этого." );
            }
        }
        else
        {
            cr.Say( SAY_NETMSG, "Сейчас дверь удерживает электромагнитный замок. Попробуйте отключить питание." );
        }

        return true;
    }
*/

    if( ( pid == PID_CROWBAR || pid == PID_MULTI_TOOL ) && @targetItem != null )
    {
        uint8 itemType = targetItem.GetType();
        if( ( itemType == ITEM_TYPE_DOOR || itemType == ITEM_TYPE_CONTAINER ) && targetItem.Val0 != 0 && _LockerIsOpen( targetItem ) )
        {

            uint16 pid_locker = 0;

            switch( targetItem.Val0 )
            {
            case 1:
                pid_locker = PID_LOCKER_LOW;
                break;
            case 2:
                pid_locker = PID_LOCKER_MED;
                break;
            case 3:
                pid_locker = PID_LOCKER_HARD;
                break;
            default:
                break;
            }
            if( pid_locker != 0 )
            {
                if( pid == PID_MULTI_TOOL )
                {
                    Item @ locker = cr.AddItem( pid_locker, 1 );
					locker.Val0 = ( targetItem.LockerComplexity > 50 ? ( targetItem.LockerComplexity - 50 ) : 0 );
                    locker.Update();
                }

                if( pid == PID_CROWBAR )
                {
                    switch( pid_locker )
                    {
                    case PID_LOCKER_LOW:
                        pid_locker = 3;
                        break;
                    case PID_LOCKER_MED:
                        pid_locker = 6;
                        break;
                    case PID_LOCKER_HARD:
                        pid_locker = 10;
                        break;
                    default:
                        pid_locker = 1;
                        break;
                    }
                    cr.AddItem( PID_CRAFT_M_BARS, Random( 1, pid_locker ) );
                }
            }
            targetItem.Val0 = 0;
            targetItem.Val1 = 0;
            targetItem.LockerComplexity = 0;
            targetItem.LockerId = 0;
            targetItem.LockerCondition = LOCKER_ISOPEN;
            targetItem.Update();
            cr.Say( SAY_SHOUT, "*Ломает замок*" );
            cr.Say( SAY_NETMSG, "Вы сняли замок." );
            return true;
        }
    }

    // Geiger counter
    if( pid == PID_GEIGER_COUNTER && useOnSelf && UseGeiger( cr, item ) )
        return true;
    if( valid( targetItem ) && targetItem.GetProtoId() == PID_GEIGER_COUNTER && UseItemOnGeiger( cr, targetItem, item ) )
        return true;


    if( pid == PID_SHOVEL && useOnSelf && UseShovel( cr, item ) )
        return true;


    if( valid( targetItem ) && ( targetItem.GetType() == ITEM_TYPE_DOOR || targetItem.GetType() == ITEM_TYPE_CONTAINER ) && UseItemOnLocker( cr, targetItem, item ) )
        return true;

	if( item.GetScriptId() != 0 )
	{
		//cr.EventUseItem( item, targetCr, targetItem, targetScen ); 
		///Увы, вот прям ТАК не работает, хз почему. Было бы очень полезно, т.к. само вызывает use_item, и не нужно заного тыкать ручкой предмет.
		
		if( UpdateBehaviour( item ) )
			cr.Say( SAY_NETMSG, "Вы подготовили предмет к использованию, используйте его снова." );
		else
			cr.Say( SAY_NETMSG, "Киньте в дискорд-канал #баги этот скрин:\n#" + item.Id + " / " + item.GetProtoId() + " [bound #" + item.GetScriptId() + "]" );
		return true;
	}

    // Take process to engine
    return false;
}

bool flashlight_off( Critter & cr, Item & item )
{
	if( valid( item ) )
	{
		Map@ map = cr.GetMap();
		if( valid( map ) ) {
		map.PlaySound( "BUTIN2.ACM", cr.HexX, cr.HexY, 1 );
		}
		
		cr.MoveItem( item.Id, item.GetCount(), SLOT_INV );
		Item@ fl_off = cr.AddItem( PID_FLASHLIGHT_OFF, 1  );
		fl_off.Val0 = item.Val0;
	
		EraseTimeEvent( item.Val3 );
		_SubItem( item, 1 );
	
		if( valid( fl_off ) )
		{
			cr.MoveItem( fl_off.Id, fl_off.GetCount(), SLOT_HAND1 );
			cr.RefreshVisible();
		}
	}
	return true;
}

//flashlight battery depletion
uint e_DepleteBattery( uint[]@ values )
{
	uint itemId = values[ 0 ];
	Item@ flashlight = GetItem( itemId );
	if( valid(flashlight) )
	{
		if( flashlight.Val0 > 0)
		{
			flashlight.Val0--;
			return REAL_MINUTE( 1 );
		}
	
		switch( flashlight.Accessory )
		{
			case( ACCESSORY_HEX ):
			{
				uint16 hexX=0, hexY=0;
				Map@ map = flashlight.GetMapPosition( hexX, hexY );
				map.AddItem( hexX, hexY, PID_FLASHLIGHT_OFF, 1 );
		
				EraseTimeEvent( flashlight.Val3 );
				_SubItem( flashlight, 1 );
				break;
			}
			case( ACCESSORY_CRITTER ):
			{
				uint cr_id = flashlight.CritId;
				Critter@ cr = GetCritter( cr_id );
				flashlight_off( cr, flashlight );
				break;
			}
			case( ACCESSORY_CONTAINER ):
			{
				uint cont_id = flashlight.ContainerId;
				Item@ cont = GetItem( cont_id );
				cont.AddItem( PID_FLASHLIGHT_OFF, 1, 0 );
				EraseTimeEvent( flashlight.Val3 );
				_SubItem( flashlight, 1 );
				break;
			}
			default:
			{
				EraseTimeEvent( flashlight.Val3 );
				_SubItem( flashlight, 1 );
			}
		}
	}
	return 0;
}

// lamp oil depletion
uint e_DepleteOil( uint[]@ values )
{
	uint itemId = values[ 0 ];
	Item@ lamp = GetItem( itemId );
	if( valid( lamp ) )
	{
		if( lamp.Val0 > 0)
		{
			lamp.Val0--;
			return REAL_MINUTE( 1 );
		}
		
		UNSETFLAG( lamp.Flags, ITEM_LIGHT );
		UNSETFLAG( lamp.Flags, ITEM_COLORIZE );
		UNSETFLAG( lamp.Flags, ITEM_COLORIZE_INV );
		lamp.Update();
		lamp.Val1 = 0;
		EraseTimeEvent( lamp.Val3 );
		lamp.Val3 = 0;
	}
	return 0;
}

uint e_FlareBurn(uint[]@ values)
{
	//assume first value you send is itemId = flareId that is burning
	uint itemId = values[0]; // can macro that index if you want
	Item@ flareBurn = GetItem(itemId);
	if(valid(flareBurn))    
	{
		DeleteItem(flareBurn); // NAPRIMER
	}
	return 0; // return for repeat time in game time
}

#include "terminal.fos"

import void Training( Critter& player, int type ) from "workout";
import bool TryTraining( Critter& cr, uint pid ) from "workout";
// #pragma bindfunc "uint Critter::ItemTransferCount() -> fonline_tnf.dll Critter_GetItemTransferCount"
import bool UseSkillOnTrappedItem( Item& trappedItem, Critter& cr, int skill ) from "trap";
import bool ComfirmedAction( Critter& cr, int skill, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen ) from "FA";

void informAboutSkill( Critter& cr, int skill, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen )
{
	string skill_name = "";
	switch( skill )
	{
		case( SK_LOCKPICK ): 	skill_name = "Взлом"; break;
		case( SK_STEAL ): 		skill_name = "Кражу"; break;
		case( SK_TRAPS ): 		skill_name = "Ловушки"; break;
		case( SK_FIRST_AID ): 	skill_name = "Первую помощь"; break;
		case( SK_DOCTOR ):		skill_name = "Докторские навыки"; break;
		case( SK_SCIENCE ): 	skill_name = "Науку"; break;
		case( SK_REPAIR ): 		skill_name = "Ремонт"; break;
		default: return;
	}
	
	string action_info = crInfo( cr ) + " применяет " + skill_name + " на ";
	
	if( valid( targetCr ) )
		action_info += crInfo( targetCr );
	else if( valid( targetItem ) )
		action_info += itemDesc( targetItem );
	else if( valid( targetScen ) )
		action_info += "сценери #" + targetScen.ProtoId;
	else
		action_info += "себя";
	
	SayLog( cr, action_info + "." );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter use skill.
bool critter_use_skill( Critter& cr, int skill, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen )
{
	informAboutSkill( cr, skill, targetCr, targetItem, targetScen );
	
	if( ComfirmedAction( cr, skill, targetCr, targetItem, targetScen )  )
		return true;
	
	if( ProcessTerminal( cr, targetScen ) ) return true;
	
	if( valid( targetItem ) )
		CheckItemMovement( cr, targetItem, skill );
	
	string exception_catcher = cr.Id + "# in " + (valid(cr.GetMap())?"@"+cr.GetMap().Id:"global") + " used " + skill + " on [" 
		+ (valid(targetCr)?targetCr.Id:0) + ", " 
		+ (valid(targetItem)?targetItem.Id:0) + ":" + (valid(targetItem)?targetItem.GetProtoId():0) + ", " 
		+ (valid(targetScen)?targetScen.ProtoId:0) + "].";
	//DebugLog( exception_catcher );
	
    bool isPlayer = cr.IsPlayer();
    bool onSelf = ( ( !valid( targetCr ) ) && ( !valid( targetItem ) ) && ( !valid( targetScen ) ) ); // TabaK

	cr.Wait(GetSkillTime(skill, cr));

	if( valid(targetItem) && UseSkillOnTrappedItem( targetItem, cr, skill ) )
		return true;

	if( skill == SK_TRAPS )
	{
		Critter@ target = ( valid( targetCr ) ? @targetCr : @cr );
		if( valid(target) && !target.IsDead() && !target.IsKnockout() )
		{
			Map@ map = target.GetMap();
			if( valid(map) ) 
			{
				Item @ Hook = map.GetItem( target.HexX, target.HexY, PID_HOLD_HOOK );
				if( valid( Hook ) )
				{
					target.Say( SAY_EMOTE, "пытается освободиться" );
					if( Hook.Val5 > 0 )
						Hook.Val5 -= Random( 0, target.Stat[ ST_LUCK ] / 2 ) + Random( 0, target.Stat[ ST_AGILITY ] / 3 );
					else
					{
						DeleteItem( Hook );
						target.Say( SAY_NETMSG, "Вы освободились." );
					}
					return true;
				}
			}
		}
	}
	
	if( ( skill == SK_REPAIR ) &&  valid( targetItem ) && targetItem.GetProtoId() == PID_MUSHROOMS) {
		if( cr.Timeout[ TO_SK_REPAIR ] > 0 ) { cr.Say( SAY_NETMSG, "Вы слишком устали, дайте отдых рукам." ); return true; }

		Map@ map = cr.GetMap();
		if( !valid(map) ) return false;
		Item@ holder = map.GetItem( cr.HexX, cr.HexY, PID_POPUP );
		if( !valid(holder) ) {
			Item@ hand = cr.GetItem( 0, SLOT_HAND1 );
			cr.RunClientScript( "client_main@Harvesting", targetItem.GetProtoId(), valid(hand) ? hand.GetProtoId() : 0, 0, null, null );
		}
		else {
			cr.Say( SAY_NETMSG, "Тут всё уже переворошили до вас.");
		}
		return true;
	}
	
    // Cars
    if( valid( targetItem ) && targetItem.GetType() == ITEM_TYPE_CAR && UseSkillOnCar( cr, targetItem, skill ) )
        return true;

    // Geiger counter
    if( valid( targetItem ) && targetItem.GetProtoId() == PID_GEIGER_COUNTER && UseSkillOnGeiger( cr, targetItem, skill ) )
        return true;

	// Управление кувшином для браги
	if( valid( targetItem ) && ( targetItem.GetProtoId() == PID_POT_ALCO ) )
	{	
		switch( skill )
		{
			case SK_REPAIR:
				LockInPlace( cr, targetItem );
				break;
			case SKILL_PICK_ON_GROUND:
				if( !FLAG( targetItem.Flags, ITEM_CAN_PICKUP ) )
				{
					ShowMenuBrew( cr, targetItem );
					return true;
				}
				else
				PickItem( cr, targetItem );
		}
		return true;
	}
	// Управление самогонным аппаратом
	if( valid( targetItem ) && IsStill(targetItem) )
	{
		if( skill == SKILL_PICK_ON_GROUND) {
			ShowMenuStill( cr, targetItem );
		}
		return true;
	}
	
	// Интерфейс однорукого бандита
	if( valid( targetItem ) && ( targetItem.GetProtoId() == PID_SLOT_MACHINE || targetItem.GetProtoId() == PID_SLOT_MACHINE2 ) )
	{
		StartMenuSlotMachine( cr, targetItem );
		return true;
	}
	
	// Интерфейс вендингового аппарата (пока сиги)
	if( valid( targetItem ) && targetItem.GetProtoId() == PID_VENDING_CIGS )
	{
		StartMenuVendingMachine( cr, targetItem );
		return true;
	}
	
    // Doors or containers
    if( valid( targetItem ) && ( targetItem.GetType() == ITEM_TYPE_DOOR || targetItem.GetType() == ITEM_TYPE_CONTAINER ) && UseSkillOnLocker( cr, targetItem, skill ) )
        return true;

    switch( skill )
    {
    case SKILL_PICK_ON_GROUND: {
		
        if( !(targetScen is null) && CanCook( targetScen ) )
        {
            return UseCookingStuff( targetScen, cr );
        }

		// Готовка на открытом пламени
		if( valid( targetItem ) && ( targetItem.GetProtoId() == PID_FIREBARREL || targetItem.GetProtoId() == PID_FIREPLACE2 || targetItem.GetProtoId() == PID_CHOPPED_FIREWOOD ) && targetItem.Val0 >= 1 )
		{	
			AskCooking( cr );
			return true;
		}

		// Меню закрепленной бочкой для огня
		if( valid( targetItem ) && ( ( targetItem.GetProtoId() == PID_FIREBARREL || targetItem.GetProtoId() == PID_BRAZIER ) && targetItem.Val0 == 0 && !FLAG( targetItem.Flags, ITEM_CAN_PICKUP ) ) )
		{	
			ShowMenuFireBarrel( cr, targetItem );
			return true;
		}

		// Scenery
		if( valid( targetScen ) )
		{
			if( water_sources.find( targetScen.ProtoId ) != -1 )
				Cleaning( cr, 0, targetScen.ProtoId );
			else
			{
				if (!TryTraining( cr, targetScen.ProtoId ) )
					cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
			}
			return true;
		}

        // Manufacture, Alcohol
       // if( isPlayer && IsStill( targetItem ) && UseStill( cr, targetItem, -1, null ) )
         //   return true;

        // Wanted
        if( valid( targetItem ) && targetItem.GetProtoId() == PID_WANTED_SIGN && WantedSignSet( targetItem, cr.Name, Random( 1000, 2000 ) ) )
            return true;
        // Explosion
        if( valid( targetItem ) && targetItem.GetProtoId() == PID_ACTIVE_MINE && OnUseExplode( cr, targetItem, null, null, null, 0 ) )
            return true;
	
        // Pick some item
        if( valid( targetItem ) )
        {
			uint16 wildplantPid = targetItem.GetProtoId();
			if( wildplants.find( wildplantPid ) != -1 ) {
				cr.Say( SAY_EMOTE, "Срывает растение" );
				if( targetItem.Val2 - 1 == targetItem.Val0 ) {
					uint16 pickedPlantPid = 0;
					switch ( wildplantPid ) 
					{
						case( PID_PLANT_BROC ):
							pickedPlantPid = PID_BROC_FLOWER;
							break;
						case( PID_PLANT_XANDER ):
							pickedPlantPid = PID_XANDER_ROOT;
							break;
						case( PID_PLANT_MURAVNIKTAR ):
							pickedPlantPid = PID_TONGUE_GECKO;
							break;
						case( PID_PLANT_TONGUE_GECKO ):
							pickedPlantPid = PID_MURAVNIKTAR;
							break;
						case( PID_PLANT_BLACK_MUSHROOMS ):
							pickedPlantPid = PID_BLACK_MUSHROOMS;
							break;
						case( PID_PLANT_PALE_MUSHROOM ):
							pickedPlantPid = PID_PALE_MUSHROOM;
							break;
						case( PID_PLANT_MUTMUSH ):
							pickedPlantPid = PID_MUTMUSH;
							break;
					}
					cr.AddItem( pickedPlantPid, targetItem.Val1 );
					cr.Say( SAY_NETMSG, "|0xFFFF00 Вы добыли немного полезных растений." );
					DeleteItem( targetItem );
				} else {
					cr.Say( SAY_NETMSG, "|0xFFFF00 Вы сорвали незрелое растение, а затем выкинули его." );
					DeleteItem( targetItem );
				}
			} else {
				PickItem( cr, targetItem );
			}
		}
		return true; 
	}
    case SKILL_PUT_CONT: {
		if( cr.ParamBase[ ST_LAST_CONT_ID ] == 0 )
			return false;

		Item@ cont = GetItem( cr.ParamBase[ ST_LAST_CONT_ID ] );

		if( !canPutItemInContainer( targetItem, cont ) || cont.Id == targetItem.Id )
		{
			cr.Say( SAY_NETMSG, "Не удалось впихнуть предмет в контейнер." );
			return true;
		}
		

		if( cont.GetProtoId() == PID_POT_ALCO )
		{
			TransferToPot( cr, targetItem, cont );
			return true;
		}	

		if( cont.GetProtoId() == PID_STILL_S )
		{
			TransferToStill( cr, targetItem, cont );
			return true;
		}	
		
		CheckCartPicMap( cont );//Обновляет картинку содержимого телеги.
		return false; 
	}
    case SKILL_TAKE_CONT: {
		// if( cr.Timeout[ TO_SK_STEAL ] > int( REAL_SECOND(1) ) && !isGM( cr ) )
		// {
			// cr.Say( SAY_NETMSG, "Вы не можете взять всё и сразу, подождите ещё " + ( cr.Timeout[ TO_SK_STEAL ] / __TimeMultiplier ) + " секунд." );
			// return true;
		// }
		
		if( targetItem.Accessory == ACCESSORY_CONTAINER || targetItem.CritId == cr.Id )
			cr.Say( SAY_EMOTE_ON_HEAD, "Берёт что-то" );
		
        if( valid(targetItem) && targetItem.Accessory == ACCESSORY_CONTAINER )
        {
			int full_weight = ItemsWeight( targetItem, cr.ItemTransferCount() );
			int freeWeight = cr.Stat[ ST_CARRY_WEIGHT ] - ItemsWeight( cr );
			if( !isGM( cr ) && freeWeight < full_weight )
			{
				cr.Say( SAY_NETMSG, "Слишком тяжело, не достать." );
				Item@ cont = GetItem( targetItem.ContainerId );
				if( valid( cont ) )
				{
					cr.ParamBase[ ST_LAST_CONT_ID ] = cont.Id;
					cr.ShowContainer( null, cont, TRANSFER_FAR_CONT );
				}
				return true;
			}
        }
		
		if( cr.ParamBase[ ST_LAST_CONT_ID ] == 0 ) return false;
		
		Item@ cont = GetItem( cr.ParamBase[ ST_LAST_CONT_ID ] );
		if( !valid( cont ) ) return false;
		
		if( cont.GetProtoId() == PID_POT_ALCO )
		{
			TransferFromPot( cr, targetItem, cont );
			return true;
		}

		CheckCartPicMap( cont );//Обновляет картинку содержимого телеги.
		return false; //Что бы предметы перенеслись, нужно вернуть false!
	}
    case SKILL_TAKE_ALL_CONT: {
		if( !isGM( cr ) ) 
		{
			cr.Say( SAY_EMOTE, "Пытается взять всё сразу" );
			cr.Say( SAY_NETMSG, "Хорошая попытка, но.. нет." );
			return true;
		}
		
		//Старый код, дефолтное поведение до 17.02.19, доступно лишь ГМам.
        if( valid( targetItem ) && targetItem.Accessory == ACCESSORY_CRITTER && targetItem.CritId == cr.Id )
        {
            int  contWeight = 0;
            Item@[] items;
            uint len = targetItem.GetItems( uint( -1 ), items );
            for( uint i = 0; i < len; i++ )
            {
                if( items[ i ] is null )
                    continue;

                contWeight += int( items[ i ].Proto.Weight * items[ i ].GetCount() );
            }

            //cr.ParamBase[ ST_CARRY_WEIGHT_EXT ] += contWeight;
            ChangeCritterSpeed( cr ); 
        }
		else
		{
			if( valid( targetItem ) )
				cr.Say( SAY_EMOTE, "Выгребает всё" );
			else
				cr.Say( SAY_EMOTE, "Обищает останки" );
		}
		return false; //Что бы предметы перенеслись, нужно вернуть false!
	} 
    case SKILL_LOOT_CRITTER: {
		cr.ParamBase[ ST_LAST_CONT_ID ] = 0;
        cr.Action( ACTION_PICK_CRITTER, 0, null );
        cr.ShowContainer( targetCr, null, TRANSFER_CRIT_LOOT );
		cr.Say( SAY_EMOTE, "Осматривает" );
        return true; }
    case SKILL_PUSH_CRITTER: {
		//cr.Say( SAY_EMOTE_ON_HEAD, "Толкает" );
        cr.Action( ACTION_PICK_CRITTER, 2, null );
		cr.StatBase[ ST_CURRENT_AP ] -= 5000;
        if( ( cr.Timeout[ TO_BATTLE ] == 0 && targetCr.Timeout[ TO_BATTLE ] == 0 ) 
			&& ( cr.Mode[ MODE_NO_PVP ] == 0 && targetCr.Mode[ MODE_NO_PVP ] == 0 )
			&& ( targetCr.IsPlayer() || ( targetCr.IsNoPlanes() && targetCr.GetTalkedPlayers( null ) == 0 ) )
			&& targetCr.Mode[MODE_NO_PUSH] == 0
			&& targetCr.MoveToDir( cr.Dir )  
			) {
				cr.Say( SAY_NETMSG, "Вы толкаете цель." );
				SayLog( cr, crInfo( cr ) + " толкает " + crInfo( targetCr ) + "." );
			}
			else
			{
				cr.Say( SAY_NETMSG, "Цель сопротивляется." );
				SayLog( cr, crInfo( cr ) + " безуспешно пытается толкнуть " + crInfo( targetCr ) + "." );
			}
				// targetCr.Say( SAY_EMOTE_ON_HEAD, "Поддается" );
			// else
				// targetCr.Say( SAY_EMOTE_ON_HEAD, "Сопротивляется" );
        return true; }
    case SK_SCIENCE: {
		if( isPlayer && inHeaven(cr) )
		{
			Pray( cr );
			return true;
		}
		
        // Manufacture, Alcohol
       // if( isPlayer && IsStill( targetItem ) && UseStill( cr, targetItem, skill, null ) )
       //     return true;
		
		// Handcuffs
        if( ( valid( targetCr ) ) && ( targetCr.Param[ HANDCUFFS ] != 0 ) || ( cr.Param[ HANDCUFFS ] != 0 ) )
        {
            if( ( valid( targetCr ) ) && ( targetCr.Param[ HANDCUFFS ] != 0 ) )                         // TabaK. Проверка серийного номера наручников.
            {
                uint KeyNumber = ( targetCr.Param[ HANDCUFFS ] >> 16 ) & 0x3FFF;
				if( KeyNumber != 0 )
					cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, 12954, "$number" + KeyNumber );
				else
					cr.Say( SAY_NETMSG, "Из этого ничего не вышло." );
            }
            if( ( cr.Param[ HANDCUFFS ] != 0 ) && ( onSelf ) )
            {
                uint KeyNumber = ( cr.Param[ HANDCUFFS ] >> 16 ) & 0x3FFF;
				if( KeyNumber != 0 )
					cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, 12954, "$number" + KeyNumber );
				else
					cr.Say( SAY_NETMSG, "Из этого ничего не вышло." );
            }
            return true;
        }

        // Radio
        if( valid( targetItem ) && FLAG( targetItem.Flags, ITEM_RADIO ) && targetItem.Accessory == ACCESSORY_CRITTER && targetItem.CritId == cr.Id )
        {
            if( isPlayer )
                EditRadioSettings( cr, targetItem );
            return true;
        }

        // if( valid( targetItem ) && ( targetItem.GetProtoId() == PID_FIRST_AID_KIT || targetItem.GetProtoId() == PID_DOCTORS_BAG ) )
        // {
            // cr.RunClientScript( "client_screen_firstais@ShowScreen", targetItem.Id, targetItem.Val4, targetItem.GetProtoId() == PID_FIRST_AID_KIT ? 0 : 1, "", null );
            // return true;
        // }
		
        if( valid( targetItem ) && targetItem.Accessory == ACCESSORY_CRITTER && AskAction( cr, targetItem ) )
			return true;
    break; }
    case SK_REPAIR: {
        // Manufacture, Alcohol
       // if( isPlayer && IsStill( targetItem ) && UseStill( cr, targetItem, skill, null ) )
       //     return true;
        // Generic repair

        if( onSelf )
            @targetCr = cr;

        if( valid( targetCr ) && targetCr.Stat[ ST_BODY_TYPE ] == BT_ROBOT )	//Починка // ремонт роботов
        {
            if( cr.Timeout[ TO_SK_REPAIR ] > 0 )
            {
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, 3401 );
                return true;
            }
			
            robotRepairSkill (cr, targetCr, false);
            ChangeCritterSpeed (targetCr);
            cr.TimeoutBase[ TO_SK_REPAIR ] = REPAIR_TIMEOUT( cr );
            return true;
        }
		
        if( valid( targetItem ) && targetItem.Accessory == ACCESSORY_CRITTER && targetItem.IsDeteriorable() )           // pm deattach if
        {
            if( IsHaveBlade( targetItem.GetProtoId() ) )
            {
                Item @ activeHand = _CritGetItemHand( cr );
                if( @activeHand == null && activeHand.GetProtoId() != PID_FLINT )
                {
                    cr.Say( SAY_NETMSG, "Для заточки лезвия нужен кремень в руке." );
                    return true;
                }
                if( !ltp_sharp_inited )
                    ltp_sharp_init();
                StartProcess( cr, LTP_SHARP, targetItem.Id, 0, 0, 10 );
                return true;
            }
            else if( AskAction( cr, targetItem ) )
                return true;
        }

        //Перенос потухших бочек для костров
		if( valid( targetItem ) && ( targetItem.GetProtoId() == PID_FIREBARREL || targetItem.GetProtoId() == PID_BRAZIER ) && targetItem.Val0 == 0 )
		{	
			LockInPlace( cr, targetItem );
			return true;
		}
		
    break; }
    case SK_SNEAK: {
		if( cr.Timeout[ TO_BATTLE ] > 0 ) 
		{
			// cr.Say( SAY_EMOTE_ON_HEAD, "блок" );
			// cr.StatBase[ ST_BLOCK ] = 1;
		} 
		else 
		{
			// cr.StatBase[ ST_BLOCK ] = 1;
			cr.ParamBase[ ST_CURRENT_AP ] -= 20 * 100;
			cr.ParamBase[ CR_IS_WINDUPED ] = 1;
			cr.Say( SAY_EMOTE, "готовится атаковать" );
			SayLog( cr, crInfo( cr ) + " готовится атаковать." );
			//cr.TimeoutBase[ TO_BATTLE ] = __FullSecond + REAL_SECOND(60);

			Item@ realWeapon = _CritGetItemHand(cr);
			ProtoItem@ weapon = valid( realWeapon ) ? GetProtoItem( realWeapon.GetProtoId() ) : null;
			int   skillNum = ( valid( weapon ) ? _WeaponSkill( weapon, 0 ) : ( valid( realWeapon ) ? SK_MELEE_WEAPONS : SK_UNARMED ) );
			uint8 weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : 
								( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );		
			
			if( weaponSubtype == WS_GUN )
				cr.SetAnims( COND_LIFE, 0, ANIM2_WINDUP );
		}
		return true; }
    case SK_STEAL: {
        if( valid( targetItem ) )
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
			return true;
        }
        else if( valid( targetCr ) )
        {
            if( targetCr.Param[ HANDCUFFS ] != 0 )
            {
				cr.ParamBase[ ST_LAST_CONT_ID ] = 0;
                cr.ShowContainer( targetCr, null, TRANSFER_CRIT_STEAL );
				return true;
            }
            else
            {
                // Loot
                if( targetCr.IsDead() )
                {
                    cr.Action( ACTION_PICK_CRITTER, 0, null );
					cr.ParamBase[ ST_LAST_CONT_ID ] = 0;
                    cr.ShowContainer( targetCr, null, TRANSFER_CRIT_LOOT );
					return true;
                }
                // Steal
                else
                {
                    if( isPlayer && cr.Timeout[ TO_SK_STEAL ] > 0 ) {
                        cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_WEARINESS );
						return true;
					}
                    else
                    {
						cr.ParamBase[ ST_LAST_CONT_ID ] = 0;
                        cr.ShowContainer( targetCr, null, TRANSFER_CRIT_STEAL );
                        cr.TimeoutBase[ TO_SK_STEAL ] = STEAL_TIMEOUT( cr );
                        cr.StatBase[ ST_LAST_STEAL_CR_ID ] = 0;
                        cr.StatBase[ ST_STEAL_COUNT ] = 0;
						return true;
                    }
                }
            }
        }
    break; }
    case SK_LOCKPICK: {
        if( ( ( valid( targetCr ) ) && ( targetCr.Param[ HANDCUFFS ] != 0 ) ) || ( ( onSelf ) && ( cr.Param[ HANDCUFFS ] != 0 ) ) )         // Взлом наручников. TabaK
        {
            if( cr.Timeout[ TO_SK_LOCKPICK ] > 0 )
            {
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, 3401 );
				return true;
			}
            else
            {
                if( valid( targetCr ) && ( ( targetCr.Param[ HANDCUFFS ] >> 29 ) & 0x1 ) == 0 )
                {
                    cr.TimeoutBase[ TO_SK_LOCKPICK ] = LOCKPICK_TIMEOUT( cr );
                    if( ( cr.Param[ SK_LOCKPICK ] + Random( 0, 150 ) + (cr.Stat[ST_LUCK] - 5)*5) > 300 - Random( 0, 50 ) )
                    {
                        Item@[] items;
                        uint8 nohome = ( targetCr.Param[ HANDCUFFS ] >> 30 ) & 0x1;

                        if( targetCr.IsNpc() )
                        {
                            targetCr.ParamBase[ MODE_NO_HOME ] = nohome;
                        }

						bool isCuffs = targetCr.CountItem( PID_HANDCUFFS_USED ) > 0;
						bool isRope =  targetCr.CountItem( PID_ROPE_USED ) > 0;
						if( isCuffs || isRope )
						{
							targetCr.DeleteItem( isCuffs ? PID_HANDCUFFS_USED : PID_ROPE_USED, 1 );
							cr.AddItem( isCuffs ? PID_BROKEN_CUFFS : PID_ROPE, 1 );
							cr.Say( SAY_NETMSG, "Вы освободили цель." );
						}
						targetCr.StatBase[ HANDCUFFS ] = 0;
                    }
                    else
                        cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, 12944 );
                }

                if( onSelf )
                {
                    cr.TimeoutBase[ TO_SK_LOCKPICK ] = LOCKPICK_TIMEOUT( cr );
                    if( ( cr.Param[ SK_LOCKPICK ] + Random( 0, 150 ) + (cr.Stat [ST_LUCK] - 5)*5) > 300 - Random( 0, 50 ) )
                    {
						bool isCuffs = cr.CountItem( PID_HANDCUFFS_USED ) > 0;
						bool isRope =  cr.CountItem( PID_ROPE_USED ) > 0;
						if( isCuffs || isRope )
						{
							cr.DeleteItem( isCuffs ? PID_HANDCUFFS_USED : PID_ROPE_USED, 1 );
							cr.AddItem( isCuffs ? PID_BROKEN_CUFFS : PID_ROPE, 1 );
							cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, isCuffs ? 12947 : 12988 );
						}
						cr.StatBase[ HANDCUFFS ] = 0;
                    }
                    else
                        cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, 12944 );
                }
				
				return true;
            }
        }
    break; }
    case SK_TRAPS: {
		uint[] BT_CARNIVORES = { BT_RAT };
		if( BT_CARNIVORES.find( cr.StatBase[ ST_BODY_TYPE ] ) != -1 )
		{
			cr.Animate( 0, ANIM2_PUNCH_RIGHT, null, true, false );
			cr.Wait( GetSkillTime(skill, cr) );
			
			if( valid( targetCr ) )
			{
				if( !targetCr.IsDead() && targetCr.IsKnockout() ) 
					cr.Say( SAY_EMOTE_ON_HEAD, "Обнюхивает" );
				
				if( targetCr.IsDead() )
				{
					string[] emotes = { "Ест", "Грызёт", "Жуёт" };
					if( Random( 1, 4 ) == 1 )
						cr.Say( SAY_EMOTE_ON_HEAD, emotes[ Random( 0, emotes.length() - 1 ) ] );
					
					if( targetCr.ParamBase[ CR_VAL0 ] < targetCr.Stat[ ST_MAX_LIFE ] )
					{
						targetCr.ParamBase[ CR_VAL0 ] += cr.Stat[ ST_MELEE_DAMAGE ];
						
						cr.StatBase[ST_EXPERIENCE] += targetCr.Stat[ST_KILL_EXPERIENCE];
						cr.StatBase[ ST_HUNGER ] += 10;
						cr.StatBase[ ST_THIRST ] += 1;
					}
					else
					{
						targetCr.StatBase[ ST_DESEASE ] = 1;
						cr.Say( SAY_NETMSG, "Здесь больше нечего есть." );
					}
				}
				if( targetCr.IsKnockout() )
				{
					cr.Say( SAY_NETMSG, "Жертва ещё жива, сперва добейте её." );
				}
				return true;
			}
			
			if( valid( targetScen ) )
			{
				uint scenPID = targetScen.ProtoId;
				if( scenPID >= 16980 && scenPID <= 16994 )
				{
					cr.StatBase[ ST_HUNGER ] += 1;
					cr.StatBase[ ST_THIRST ] += 10;
					cr.Say( SAY_EMOTE, "Пьёт" );
				}
				else
					cr.Say( SAY_EMOTE_ON_HEAD, "Обнюхивает" );
				
				return true;
			}
		}
			
		if( valid(targetCr) ) 
		{
			if( cr.Timeout[ TO_SK_STEAL ] > 0 && !isGM( cr ) ) 
			{
				if( !targetCr.IsDead() ) targetCr.Say(SAY_EMOTE,"Сопротивляется" );
				cr.Say(SAY_EMOTE,"Пытается что-то отобрать" );
				cr.Say(SAY_NETMSG, "Вы слишком устали, что бы успешно отобрать вещь.");
				return true;
			}
			bool CanResist = true;
			
			Item@[] items;
			Item@[] items0;
			Item@[] items1;
			Item@[] items2;
			Item@[] items3;
			uint itemscount = targetCr.GetItems( SLOT_HAND1, items );
			uint itemscount0 = targetCr.GetItems( SLOT_HAND2, items0 );
			uint itemscount1 = targetCr.GetItems( SLOT_HEAD, items1 );
			uint itemscount2 = targetCr.GetItems( SLOT_BACK, items2 );
			uint itemscount3 = targetCr.GetItems( SLOT_MISC, items3 );
			
			if( itemscount > 0 )
			{
				Item@ hand = items[0];
				if(valid(hand)) {
					int pid = hand.GetProtoId();
					if( pid == PID_HANDCUFFS || pid == PID_ROPE_USED ) {
						CanResist = false;
					}
				}
			}
			
			if( itemscount0 > 0 )
			{
				Item@ hand = items0[0];
				if(valid(hand)) {
					int pid = hand.GetProtoId();
					if( pid == PID_HANDCUFFS || pid == PID_ROPE_USED ) {
						CanResist = false;
					}
				}
			}
			
			if( itemscount1 > 0 )
			{
				Item@ head = items1[0];
				if(valid(head)) {
					int pid = head.GetProtoId();
					if( pid == PID_COLLAR ) {
						CanResist = false;
					}
				}
			}
			
			if( targetCr.IsKnockout() || targetCr.IsDead() || targetCr.Stat[ HANDCUFFS ] != 0 || !CanResist || isGM( cr ) ) 
			{
				if( itemscount > 0 )
				{
					Item@ hand = items[0];
					if(valid(hand)) {
						int pid = hand.GetProtoId();
						if( pid != PID_HANDCUFFS && pid != PID_ROPE_USED ) {
							targetCr.MoveItem( items[ 0 ].Id, itemscount, SLOT_INV );
						}
					}
				}
				if( itemscount0 > 0 )
				{
					Item@ hand = items0[0];
					if(valid(hand)) {
						int pid = hand.GetProtoId();
						if( pid != PID_HANDCUFFS && pid != PID_ROPE_USED )
							targetCr.MoveItem( items0[ 0 ].Id, itemscount, SLOT_INV );
					}
				}

				if( itemscount1 > 0 )
				{
					Item@ head = items1[0];
					if(valid(head)) {
						int pid = head.GetProtoId();
						if( pid != PID_COLLAR )
							targetCr.MoveItem( items1[ 0 ].Id, itemscount, SLOT_INV );
					}
				}

				if( itemscount2 > 0 )
				{
					Item@ back = items2[0];
					if(valid(back)) {
						int pid = back.GetProtoId();
						targetCr.MoveItem( items2[ 0 ].Id, itemscount, SLOT_INV );
					}
				}
				
				if( itemscount3 > 0 )
				{
					Item@ misc = items3[0];
					if(valid(misc)) {
						int pid = misc.GetProtoId();
						targetCr.MoveItem( items3[ 0 ].Id, itemscount, SLOT_INV );
					}
				}


				if( StealContainerOrArmor( cr, targetCr, targetItem ) ) {
					return true;
				}
			}
		}        
		if( valid( targetItem ) )
        {
            uint16 pid = targetItem.GetProtoId();
            if( ( pid == PID_ACTIVE_DYNAMITE || pid == PID_ACTIVE_PLASTIC_EXPLOSIVE || pid == PID_ACTIVE_MINE ) && OnUseExplode( cr, targetItem, null, null, null, 0 ) ) {
                return true;
			}
			
			if( targetItem.GetType() == ITEM_TYPE_CONTAINER && StealContainerOrArmor( cr, targetCr, targetItem ) ) {
				return true;
			}
        }
		if( valid( targetScen ) )
		{
			if( water_sources.find( targetScen.ProtoId ) != -1 ) {
				Cleaning( cr, 0, targetScen.ProtoId );
			}
			else
				if( !TryTraining( cr, targetScen.ProtoId ) ) {
					cr.Say( SAY_EMOTE, "Осматривает " + targetScen.ProtoId );
				}
			return true;
		}
	break; 
	}
	default: 
	break;
    }

	return false;
}

import void start_cleaning( Critter& player, bool handsOnly ) from "test";

bool useWater( Critter& cr )
{
	uint[][] water_bottles = 
	{
		{ PID_BOTTLE_DIRTY_FULL, PID_BOTTLE_EMPTY },
		{ PID_GLASS_BOTTLE_DIRTY_FULL, PID_BOTTLE_GLASS },
		{ PID_GLASS_BOTTLE_FULL, PID_BOTTLE_GLASS }, 
		{ PID_BOTTLE_FULL, PID_BOTTLE_EMPTY }, 
		{ PID_CLEAN_WATER2, PID_BOTTLE_GLASS },
	};
	
	Item@ water = null;
	int n = -1;
	
	for( uint i = 0; i < water_bottles.length(); i++ )
	{
		if( water_bottles[i].length() < 2 ) continue;
		@water = cr.GetItem( water_bottles[i][0], -1 );

		if( valid(water) ) 
		{	
			if( water_bottles[i][0] == PID_BOTTLE_DIRTY_FULL || water_bottles[i][0] == PID_GLASS_BOTTLE_DIRTY_FULL )
				AffectRadiation( cr, 1 );

			cr.AddItem( water_bottles[i][1], 1 );

			Map@ map = cr.GetMap();	
			map.PlaySound( "splash.ogg", cr.HexX, cr.HexY, 5 );	
			_SubItem( water, 1 );
			return true;
		}
	}
	
	return false;
}

bool isHandWasher( int water_source )
{
	uint[] hand_washers = { 2615, 2619, PID_BADYA };
	return hand_washers.find(water_source) != -1;
}

bool PrepareCleaning( Critter& player, Critter& target, int water_source )
{
	if( water_source == 0 ) //Если нет стороннего источника воды
	{
		if( !useWater( player ) && !useWater( target ) )
		{
			player.Say( SAY_NETMSG, "У вас нет воды для этого." );
			return false;
		}
	}
	else 
	{
		if( !isHandWasher( water_source ) ) //Если моешься в душе, а не просто руки с мылом помыл.
		{
			//Тут будет выпадение вещей из инвентаря, поломка раций и износ брони/оружия.
			Map@ map = player.GetMap();	
			map.PlaySound( "shower.ogg", player.HexX, player.HexY, 5 );	
		}
		else
		{
			Map@ map = player.GetMap();	
			if( water_source == PID_BADYA ) {
				map.PlaySound( "splash.ogg", player.HexX, player.HexY, 5 );
			} else {
			map.PlaySound( "water_running.ogg", player.HexX, player.HexY, 5 );	
			}
		}
	}
	
	return true;
}

//import void Cleaning( Critter& player, uint soap_pid, int water_source ) from "main";
void Cleaning( Critter& player, uint soap_pid, int water_source ) //exported
{
	Cleaning( player, player, soap_pid, water_source );
}

//import void Cleaning( Critter& player, Critter& target, uint soap_pid, int water_source ) from "main";
void Cleaning( Critter& player, Critter& target, uint soap_pid, int water_source ) //exported
{
	if( PrepareCleaning( player, target, water_source ) )
		SoapEffect( player, target, soap_pid, water_source );
}

void SoapEffect( Critter& player, Critter& target, uint soap_pid, int water_source )
{
	Critter@ owner = @player;
	Item@ soap = getSoap( player, soap_pid );
	if( !valid( soap ) )
	{
		@soap = getSoap( target, soap_pid );
		
		if( valid( soap ) )
			@owner = @target;
	}
	
	bool isHandsOnly = isHandWasher( water_source );
	
	int pid = valid(soap) ? soap.GetProtoId() : 0;
	switch( pid )
	{
		case( PID_ITSOAP01 ):
			owner.Say( SAY_NETMSG, "Вы используете новый кусок мыла." );
			_SubItem( soap, 1 );
			@soap = owner.AddItem( PID_ITSOAP01_PRT, 1 );
			
		case( PID_ITSOAP01_PRT ):
			target.Say( SAY_EMOTE_ON_HEAD, "Моет" + ( isHandsOnly ? " руки" : "ся" ) + " хозяйственным мылом" );
			target.ParamBase[ CR_DIRTINESS ] = ( target.ParamBase[ CR_DIRTINESS ] * 0.8 ) - 5;

			soap.Val0--;
			soap.Update();
			if( soap.Val0 < 1 )
			{
				owner.Say( SAY_NETMSG, "Вы использовали последние крохи мыла." );
				_SubItem( soap, 1 );
			}
		break;
		
		case( PID_FPSHL6 ):
			owner.Say( SAY_NETMSG, "Вы используете новый кусок мыла." );
			_SubItem( soap, 1 );
			@soap = owner.AddItem( PID_FPSHL6_PRT, 1 );
			
		case( PID_FPSHL6_PRT ):
			target.Say( SAY_EMOTE_ON_HEAD, "Моет" + ( isHandsOnly ? " руки" : "ся" ) + " душистым мылом" );
			target.ParamBase[ CR_DIRTINESS ] = ( target.ParamBase[ CR_DIRTINESS ] * 0.6 ) - 10;
			
			if( target.ParamBase[ CR_DIRTINESS ] <= 0 && target.GetTimeEvents( CTE_ROTTEN, null, null, null ) < 1 )
				target.AddTimeEvent( "cte_aroma", REAL_SECOND(15), CTE_ROTTEN, 0 );

			soap.Val0--;
			soap.Update();
			if( soap.Val0 < 1 )
			{
				owner.Say( SAY_NETMSG, "Вы использовали последние крохи мыла." );
				_SubItem( soap, 1 );
			}
		break;
		
		default:
			target.Say( SAY_EMOTE_ON_HEAD, "Ополаскивает" + ( isHandsOnly ? " руки" : "ся" ) );
			target.ParamBase[ CR_DIRTINESS ] -= 1 + Random( 0, target.ParamBase[ CR_DIRTINESS ] * 0.2 );
			
			if( water_source > 0 ) {
				start_cleaning( target, isHandsOnly );
			}
		break;
	}
}

Item@ getSoap( Critter& player, uint soap_pid )
{
	Item@ soap;
	uint[] soap_pids = { PID_ITSOAP01_PRT, PID_FPSHL6_PRT, PID_ITSOAP01, PID_FPSHL6 };
	for( uint i = 0, l = soap_pids.length(); i < l; i++ )
	{
		@soap = player.GetItem( soap_pid == 0 ? soap_pids[i] : soap_pid, -1 );
		if( valid( soap ) )
			break;
	}
	return soap;
}

//import bool inHeaven( Critter& cr ) from "main";
bool inHeaven( Critter& cr ) //exported
{
	if( cr.IsDead() ) return false;
	
	Map@ crMap = cr.GetMap();
	if( !valid( crMap ) ) return false;
	
	Location@ crLoc = crMap.GetLocation();
	if( !valid( crLoc ) ) return false;
	
	int pid = crLoc.GetProtoId();
	
	//pid == LOCATION_Deadloc
	return pid == LOCATION_Hell; //Лока для трупов отключена.
}

import void GetRandomPidFromCategory( Critter& cr, uint cat ) from "store";

void TestPray( Critter& cr, int, int, int )
{
	Pray( cr );
}

void Pray( Critter& cr )
{
	cr.Say( SAY_EMOTE, "Молится" );
	
	GameVar@ canPray = GetGlobalVar( GVAR_Pray_Battleground );
	if( canPray.GetValue() == 0 ) {
		cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), 100 * Random( 5, 10 ), cr.HexX, cr.HexY );
		return;
	}		
	
	if( cr.GetTimeEvents( CTE_PRAY, null, null, null ) == 0 )
		cr.AddTimeEvent( "cte_PRAY", REAL_SECOND( 3 ), CTE_PRAY, 0 );
}

uint cte_PRAY( Critter& cr, int identifier, uint& rate )
{
	string[] data = { "main@answer_PrayForItem", "Вы молитесь, что бы получить..", "Лут", "Пожертвовать всем", "Исцеление", "Искупление" };
		//"Холодное", "Стрелковое", "Аммуниция", "Метательное", "Инструменты", "Броня", "Вещества", "Пища", "Ценности", "Расходники", "Хлам", "Пожертвовать всем", "Исцеление", "Искупление" };
	DIALOG_MENU( cr, data );
	return 0;
}

void answer_PrayForItem( Critter& cr, uint answerI, string& answerS )
{
	GetRandomPidFromCategory( cr, answerI );
}

void Say( Critter@ target, uint type, string text )
{
	if( valid( target ) )
		target.Say( type, text );
}

bool StealContainerOrArmor( Critter& cr, Critter@ targetCr, Item@ targetItem )
{
	bool LootedRucksack = false;
	Item@[] RuckSacks;
	
	bool isCritter = valid( targetCr );
	
	if( isCritter )
		targetCr.GetItems( -1, RuckSacks );
	else if( valid( targetItem ) )
		targetItem.GetItems( uint( -1 ), RuckSacks );
	else
		return false;
	
	for( uint i = 0, iEnd = RuckSacks.length(); i < iEnd; i++ )
	{
		int pid = RuckSacks[i].GetProtoId();
		bool isContainer = RuckSacks[i].GetType() == ITEM_TYPE_CONTAINER;
		bool isBag = (pid == PID_BAG);
		bool isPack = (pid == PID_BACKPACK);
		if( isBag || isPack || isContainer ) {
			if( !isGM( cr ) ) {
				cr.Say(SAY_EMOTE,"Снимает " + (isPack ? "рюкзак" : "что-то" ));
				MoveItem( RuckSacks[i], 1, cr.GetMap(), cr.HexX, cr.HexY );
				Say( targetCr, SAY_NETMSG, "Вы не в силах сопротивляться, пока у вас отбирают " + (isPack ? "рюкзак" : "что-то" ) + "." );
				cr.TimeoutBase[ TO_SK_STEAL ] = __FullSecond + REAL_SECOND( 15 );
			} else {
				MoveItem( RuckSacks[i], 1, cr );
				cr.Say( SAY_NETMSG, "Вы забрали " + (isPack ? "рюкзак" : "что-то" ) + ( isCritter ? " у игрока" : " с тела" ) + "."  );
			}
			LootedRucksack = true;
			return true;
		}
	}
	if( isCritter && !LootedRucksack ) 
	{
		Item@[] armors;
		uint count = targetCr.GetItems( SLOT_ARMOR, armors );
		if( count == 0 || !valid(armors[0]) ) 
		{
			cr.Say( SAY_NETMSG, "Из этого ничего не вышло." );
			return true;
		}
		
		cr.Say( SAY_EMOTE, "пытается снять броню" );
		cr.Say( SAY_NETMSG, "Вы снимаете с цели всё что можете." );
		targetCr.Say( SAY_NETMSG, "Вашу броню пытаются снять!" );
		if( uint( cr.Stat[ ST_LAST_STEAL_CR_ID ] ) == targetCr.Id ) {
			cr.TimeoutBase[ TO_SK_STEAL ] = __FullSecond + REAL_SECOND( 15 );
			cr.StatBase[ ST_STEAL_COUNT ] ++;
			TryToTakeArmor( cr, targetCr );
		} else {
			if( isGM( cr ) ) {
				cr.Say( SAY_NETMSG, "Вы забрали у персонажа броню." );
				cr.StatBase[ ST_STEAL_COUNT ] = 7;
				TryToTakeArmor( cr, targetCr );
			}
			cr.StatBase[ ST_STEAL_COUNT ] = 0;
			cr.StatBase[ ST_LAST_STEAL_CR_ID ] = targetCr.Id;
		}
		return true;
	}
	return false;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reload weapon.
// If ammo is not valid than only unload.

// ltp reload pm add

#define RELOAD_BASE             ( 6000 )
#define RELOAD_BASE_REVOLVER    ( 500 )
#define RELOAD_BASE_PISTOL      ( 2000 )
#define RELOAD_BASE_RIFLE       ( 6000 )
#define RELOAD_BASE_SHOTGUN     ( 1000 )
#define RELOAD_BASE_SMG         ( 6000 )
#define RELOAD_BASE_ENRPIST     ( 4000 )
#define RELOAD_BASE_ENRRFL      ( 8000 )
#define RELOAD_BASE_BIGGUN      ( 10000 )

bool ltp_reload_inited = false;

void ltp_reload_init()
{
    LTPREG( LTP_RELOAD, process_reload )
    ltp_reload_inited = true;
}

uint process_reload( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESSD( LTP_RELOAD )


    Item @ weapon = GetItem( param0 );
    if( @weapon == null )
        return 0;

    Item @ ammo;
    if( param1 != 0 )
        @ammo = GetItem( param1 );


    if( not valid( ammo ) || ( weapon.AmmoCount > 0 && weapon.AmmoPid != ammo.GetProtoId() ) )
    {
        if( weapon.AmmoPid != 0 )
        {
            Item@ existAmmo = cr.GetItem( weapon.AmmoPid, -1 );
            if( not valid( existAmmo ) )
                cr.AddItem( weapon.AmmoPid, weapon.AmmoCount );
            else
                _IncItem( existAmmo, weapon.AmmoCount );
        }
        weapon.AmmoCount = 0;
    }

    if( valid( ammo ) )
    {
        uint count = MIN( ammo.GetCount(), weapon.Proto.Weapon_MaxAmmoCount - weapon.AmmoCount );
        weapon.AmmoCount += count;
        weapon.AmmoPid = ammo.GetProtoId();
        _SubItem( ammo, count );
    }

    weapon.Update();

    return 0;
}

// ltp reload end

void critter_reload_weapon( Critter& cr, Item& weapon, Item@ ammo )
{
	cr.Wait(500);//GetProtoTime(weapon.Proto, USE_RELOAD, cr)
		
    // Special weapons
    if( weapon.Proto.Weapon_Caliber == 0 )
    {
        if( weapon.GetProtoId() == PID_SOLAR_SCORCHER || weapon.GetProtoId() == PID_SUN || weapon.GetProtoId() == PID_SUN2 || weapon.GetProtoId() == PID_SUN3 ) // Скорчер / перезарядка
        {
            if( IS_NIGHT( __Hour ) )
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SOLAR_SCORCHER_NO_LIGHT );
            else
            {
                weapon.AmmoCount = weapon.Proto.Weapon_MaxAmmoCount;
                weapon.Update();
            }
        }
        else if( ( weapon.GetProtoId() == PID_FIREBREATH && cr.StatBase[ ST_BODY_TYPE ] == BT_GECKO ) || ( weapon.GetProtoId() == PID_KIRE && cr.StatBase[ ST_BODY_TYPE ] == BT_ROBOT ) )
        {
                weapon.AmmoCount = weapon.Proto.Weapon_MaxAmmoCount;
                weapon.Update();
		/*
            uint wid = weapon.Id;
            uint[] indexes;
            uint[] durations;
            if( cr.GetTimeEvents( 10, indexes, durations, null ) == 0 )
                cr.AddTimeEvent( "cte_slowReload", 600, CTE_SLOWRELOAD, wid );
		*/
        }

        return;
    }

    // Other weapons
    // Unload


    // ltp reload pm add

    if( cr.IsPlayer() )   // temporary
    {
		//if (cr.GetTimeEvents( CTE_SLOWRELOAD, null, null, null ) > 0) cr.EraseTimeEvents( CTE_SLOWRELOAD );
	 
		cr.Say( SAY_EMOTE_ON_HEAD, "Заряжает оружие" );

		if( !valid( ammo ) )
		{
			@ammo = cr.GetItem( weapon.AmmoPid, -1 );
			int need_ammo = weapon.Proto.Weapon_MaxAmmoCount - weapon.AmmoCount;
			if( !valid( ammo ) && need_ammo > 0 && cr.CountItem( PID_AMMO_BELT ) > 0 )
			{
				Item@[] inventory;
				Item@[] belts; belts.resize(0);
				uint count = cr.GetItems( -1, inventory );
				for( uint i = 0; i < count; i++ )
					if( inventory[i].GetProtoId() == PID_AMMO_BELT )
						belts.insertLast( inventory[i] );
				
				Item@ finded;
				int local_max = 0;
				for( uint i = 0; i < belts.length(); i++ )
				{
					@finded = belts[i].GetItem( weapon.AmmoPid, 0 );
					if( valid( finded ) && int( finded.GetCount() ) >= local_max )
					{
						local_max = finded.GetCount();
						@ammo = @finded;
					}
				}
				if( valid( ammo ) )
					cr.Say( SAY_EMOTE_ON_HEAD, "Заряжается из патронташа" );
			}
		}
		
		if( !valid( ammo ) ) //Если же не найдено патронов того же типа, ищем подобные, по калибру.
		{
			Item@[] inventory;
			uint count = cr.GetItems( -1, inventory );
			for( uint i = 0; i < count; i++ )
				if( inventory[i].Proto.Ammo_Caliber == weapon.Proto.Weapon_Caliber )
				{
					cr.Say( SAY_EMOTE_ON_HEAD, "Меняет тип боеприпаса" );
					@ammo = inventory[i];
					break;
				}
		}		
	 
		uint16 weapPid = weapon.GetProtoId(), skill = 1, reloadBaseTime = 0;

        switch( weapPid )
        {
        case PID_GENRIS_RIFLE:
            reloadBaseTime = RELOAD_BASE_REVOLVER;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_ANACONDA:
            reloadBaseTime = RELOAD_BASE_REVOLVER;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_44_MAGNUM_REVOLVER:
            reloadBaseTime = RELOAD_BASE_REVOLVER;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_FLARE_GUN:
            reloadBaseTime = RELOAD_BASE_REVOLVER;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_REVOLVER_LOW:
            reloadBaseTime = RELOAD_BASE_REVOLVER;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_ZIP_GUN:
            reloadBaseTime = RELOAD_BASE_REVOLVER;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_9MM_MAUSER:
            reloadBaseTime = RELOAD_BASE_PISTOL;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_10MM_PISTOL:
            reloadBaseTime = RELOAD_BASE_PISTOL;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_14MM_PISTOL:
            reloadBaseTime = RELOAD_BASE_PISTOL;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_DESERT_EAGLE:
            reloadBaseTime = RELOAD_BASE_PISTOL;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_DESERT_EAGLE_EXT_MAG:
            reloadBaseTime = RELOAD_BASE_PISTOL;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_223_PISTOL:
            reloadBaseTime = RELOAD_BASE_PISTOL;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_NEEDLER_PISTOL:
            reloadBaseTime = RELOAD_BASE_PISTOL;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_PISTOL_LOW:
            reloadBaseTime = RELOAD_BASE_PISTOL;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_SMOKE_GUN_LOW:
            reloadBaseTime = RELOAD_BASE_PISTOL;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
		case PID_SHOTPISTOL_LOW:
            reloadBaseTime = RELOAD_BASE_SHOTGUN;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_SAWED_OFF_SHOTGUN:
            reloadBaseTime = RELOAD_BASE_SHOTGUN;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_SHOTGUN:
            reloadBaseTime = RELOAD_BASE_SHOTGUN;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_COMBAT_SHOTGUN:
            reloadBaseTime = RELOAD_BASE_SHOTGUN;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_REMINGTON:
            reloadBaseTime = RELOAD_BASE_SHOTGUN;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_HUNTING_RIFLE:
            reloadBaseTime = RELOAD_BASE_RIFLE;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_SCOPED_HUNTING_RIFLE:
            reloadBaseTime = RELOAD_BASE_RIFLE;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_SPRINGER_RIFLE:
            reloadBaseTime = RELOAD_BASE_SHOTGUN;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_ASSAULT_RIFLE:
            reloadBaseTime = RELOAD_BASE_RIFLE;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_ASSAULT_RIFLE_EXT_MAG:
            reloadBaseTime = RELOAD_BASE_RIFLE;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_SNIPER_RIFLE:
            reloadBaseTime = RELOAD_BASE_RIFLE;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_FN_FAL:
            reloadBaseTime = RELOAD_BASE_RIFLE;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_RED_RYDER_BB_GUN:
            reloadBaseTime = RELOAD_BASE_RIFLE;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_RED_RYDER_LE_BB_GUN:
            reloadBaseTime = RELOAD_BASE_RIFLE;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_REV_RIFLE_LOW:
            reloadBaseTime = RELOAD_BASE_SHOTGUN;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_SNIPER_GUN_LOW:
            reloadBaseTime = RELOAD_BASE_SHOTGUN;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_GECKO_LOW:
            reloadBaseTime = RELOAD_BASE_SMG;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_AUTOGUN_LOW:
            reloadBaseTime = RELOAD_BASE_SMG;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_10MM_SMG:
            reloadBaseTime = RELOAD_BASE_SMG;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_HK_P90C:
            reloadBaseTime = RELOAD_BASE_SMG;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_GREASE_GUN:
            reloadBaseTime = RELOAD_BASE_SMG;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_DRUM_GUN_LOW:
            reloadBaseTime = RELOAD_BASE_SMG;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_MAUSER_SMG:
            reloadBaseTime = RELOAD_BASE_SMG;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        case PID_FLAMER:
            reloadBaseTime = RELOAD_BASE_BIGGUN;
            skill = cr.ParamBase[ SK_BIG_GUNS ];
            break;
        case PID_SOUND_BLASTER:
            reloadBaseTime = RELOAD_BASE_BIGGUN;
            skill = cr.ParamBase[ SK_BIG_GUNS ];
            break;
        case PID_GATLING_LOW:
            reloadBaseTime = RELOAD_BASE_BIGGUN;
            skill = cr.ParamBase[ SK_BIG_GUNS ];
            break;
        case PID_SAWGUN_LOW:
            reloadBaseTime = RELOAD_BASE_BIGGUN;
            skill = cr.ParamBase[ SK_BIG_GUNS ];
            break;
        case PID_14mm_BIGGUN2_LOW:
            reloadBaseTime = RELOAD_BASE_BIGGUN;
            skill = cr.ParamBase[ SK_BIG_GUNS ];
            break;
        case PID_3GUN_LOW:
            reloadBaseTime = RELOAD_BASE_BIGGUN;
            skill = cr.ParamBase[ SK_BIG_GUNS ];
            break;
        case PID_BIGGUN_LOW:
            reloadBaseTime = RELOAD_BASE_SHOTGUN;
            skill = cr.ParamBase[ SK_BIG_GUNS ];
            break;
        case PID_GRENADELAUNCHER:
            reloadBaseTime = RELOAD_BASE_BIGGUN;
            skill = cr.ParamBase[ SK_BIG_GUNS ];
            break;
        case PID_LASER_PISTOL:
            reloadBaseTime = RELOAD_BASE_ENRPIST;
            skill = cr.ParamBase[ SK_ENERGY_WEAPONS ];
            break;
        case PID_MAGNETO_LASER_PISTOL:
            reloadBaseTime = RELOAD_BASE_ENRPIST;
            skill = cr.ParamBase[ SK_ENERGY_WEAPONS ];
            break;
        case PID_LASER_PISTOL_LOW:
            reloadBaseTime = RELOAD_BASE_ENRPIST;
            skill = cr.ParamBase[ SK_ENERGY_WEAPONS ];
            break;
        case PID_PLASMA_SMG_LOW:
            reloadBaseTime = RELOAD_BASE_ENRRFL;
            skill = cr.ParamBase[ SK_ENERGY_WEAPONS ];
            break;
        case PID_LASER_RIFLE_LOW:
            reloadBaseTime = RELOAD_BASE_ENRRFL;
            skill = cr.ParamBase[ SK_ENERGY_WEAPONS ];
            break;
        default:
            reloadBaseTime = RELOAD_BASE_BIGGUN;
            skill = cr.ParamBase[ SK_SMALL_GUNS ];
            break;
        }
		
		if( not valid( ammo ) || ( weapon.AmmoCount > 0 && weapon.AmmoPid != ammo.GetProtoId() ) || ( weapon.AmmoCount == weapon.Proto.Weapon_MaxAmmoCount ) )
        {
            if( weapon.AmmoPid != 0 && weapon.AmmoCount > 0 )
            {
				cr.Say( SAY_EMOTE_ON_HEAD, "Разряжает оружие" );
                Item@ existAmmo = cr.GetItem( weapon.AmmoPid, -1 );
                if( not valid( existAmmo ) )
                    cr.AddItem( weapon.AmmoPid, weapon.AmmoCount );
                else
                    _IncItem( existAmmo, weapon.AmmoCount );
				weapon.AmmoCount = 0;
				weapon.Update();
            }
			return;
        }
		
        int reloadTime = ( RELOAD_BASE + reloadBaseTime ) - ( ( cr.StatBase[ ST_AGILITY ] * 200 ) + ( skill * 40 ) );
        reloadTime = CLAMP( reloadTime, 1000, 10000 );
		if( valid( ammo ) ) weapon.Val1 = ammo.Id;
		else weapon.Val1 = 0;
		if ( reloadBaseTime == RELOAD_BASE_SHOTGUN || reloadBaseTime == RELOAD_BASE_REVOLVER) 
			cr.AddTimeEvent( "cte_slowReload_one", /*reloadTime*__TimeMultiplier*0.001*/ REAL_SECOND(2), CTE_SLOWRELOAD, weapon.Id);
		else cr.AddTimeEvent( "cte_slowReload", /*reloadTime*__TimeMultiplier*0.001*/ REAL_SECOND(2), CTE_SLOWRELOAD, weapon.Id);
		cr.ModeBase[ MODE_NO_RUN ] = 2; 
		weapon.SetEvent( ITEM_EVENT_MOVE, "e_ReloadInterrupt" );
    }
    else
    {
        /* old!!! used for npc temporary */
        if( not valid( ammo ) || ( weapon.AmmoCount > 0 && weapon.AmmoPid != ammo.GetProtoId() ) )
        {
            if( weapon.AmmoPid != 0 )
            {
                Item@ existAmmo = cr.GetItem( weapon.AmmoPid, -1 );
                if( not valid( existAmmo ) )
                    cr.AddItem( weapon.AmmoPid, weapon.AmmoCount );
                else
                    _IncItem( existAmmo, weapon.AmmoCount );
            }
            weapon.AmmoCount = 0;
        }

        // Load
        if( valid( ammo ) )
        {
            uint count = MIN( ammo.GetCount(), weapon.Proto.Weapon_MaxAmmoCount - weapon.AmmoCount );
            weapon.AmmoCount += count;
            weapon.AmmoPid = ammo.GetProtoId();
            _SubItem( ammo, count );
        }

        weapon.Update();
        /*end of old!!! */
    }
}

void e_ReloadInterrupt( Item& item, Critter& crit, uint8 fromSlot )
{
    if(fromSlot == SLOT_HAND1 )
    {
	ChangeCritterSpeed( crit );
    crit.EraseTimeEvents( CTE_SLOWRELOAD );
	item.SetEvent( ITEM_EVENT_MOVE, null );
    }
}

uint cte_aroma( Critter& cr, int identifier, uint& rate )
{
	if( cr.ParamBase[ CR_DIRTINESS ] <= 0 ) {
		cr.Say( SAY_EMOTE_ON_HEAD, "приятно пахнет" );
		return REAL_MINUTE( 1 );
	}
	return 0;
}

uint cte_slowReload_one( Critter& cr, int identifier, uint& rate )
{
    Item@ weapon = GetItem( rate );
	Item@ hand = _CritGetItemHand( cr );
    if( !valid( weapon ) || !valid(hand) || weapon.Id != hand.Id || weapon.AmmoCount >= weapon.Proto.Weapon_MaxAmmoCount ) 
	{ 
		ChangeCritterSpeed( cr ); 
		return 0; 
	}

	Item@ ammo;
	if ( weapon.Val1 > 0 ) @ammo =  GetItem( weapon.Val1 );
	
	if( valid( ammo ) )
    {
        weapon.AmmoCount++;
        weapon.AmmoPid = ammo.GetProtoId();
        _SubItem( ammo, 1 );
    }
	weapon.Update();
	
	if( !valid( ammo ) ) 
	{ 
		ChangeCritterSpeed( cr ); 
		return 0; 
	}
	//if( weapon.AmmoCount >= weapon.Proto.Weapon_MaxAmmoCount ) {ChangeCritterSpeed( cr ); return 0;}
    return REAL_SECOND(1);
}

uint cte_slowReload( Critter& cr, int identifier, uint& rate )
{
    Item@ weapon = GetItem( rate );
	Item@ hand = _CritGetItemHand( cr );
    if( !valid( weapon ) || !valid(hand) || weapon.Id != hand.Id ) { ChangeCritterSpeed( cr ); return 0; }
	
	Item @ ammo;
	if ( weapon.Val1 > 0 ) @ammo = GetItem( weapon.Val1 );
	
	if( valid( ammo ) )
    {
        uint count = MIN( ammo.GetCount(), weapon.Proto.Weapon_MaxAmmoCount - weapon.AmmoCount );
        weapon.AmmoCount += count;
        weapon.AmmoPid = ammo.GetProtoId();
        _SubItem( ammo, count );
    }
	weapon.Update();
	ChangeCritterSpeed( cr );
    return 0;
}
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Kriegwolf: Limb management timed event
uint cte_limb_management (Critter& cr, int identifier, uint& rate) {
	return 0; //Самоубивает включенные ивенты.
	/* //Отключено, т.к. игровой опыт данного механа слишком жёсткий.
	Map@  map = cr.GetMap();
	bool emoteSaid = false;
	bool screen = false;
	int maxHP = cr.Stat [ST_MAX_LIFE];
	int i = BP_LIMBS_BEGIN;
	int currentHP = 0;
	int roll = Random( 0, 1 );
	if (cr.ParamBase [BP_BLOOD_LOSS] > 0) cr.ParamBase [BP_BLOOD_LOSS] -= 4;
	if (cr.ParamBase [BP_BLOOD_LOSS] > 0.8 * maxHP) {
		cr.Say (SAY_NETMSG, "Вы чувствуете смертельный холод и усталость.");
	} else if (cr.ParamBase [BP_BLOOD_LOSS] > 0.6 * maxHP) {
		cr.Say (SAY_NETMSG, "Вы чувствуете сильную усталость и головокружение");
	} else if (cr.ParamBase [BP_BLOOD_LOSS] > 0.4 * maxHP) {
		cr.Say (SAY_NETMSG, "Вы чувствуете усталость и головокружение");
	} else if (cr.ParamBase [BP_BLOOD_LOSS] > 0.2 * maxHP) {
		cr.Say (SAY_NETMSG, "Вы чувствуете легкое головокружение");
	}
	if (cr.ParamBase [ST_CURRENT_HP] > maxHP - __DeadHitPoints - cr.ParamBase [BP_BLOOD_LOSS] && !cr.IsDead() ) cr.ParamBase [ST_CURRENT_HP] = maxHP - __DeadHitPoints - cr.ParamBase [BP_BLOOD_LOSS];
	while (i <= BP_LIMBS_END) {
		currentHP = cr.ParamBase [i];
		if ( currentHP > 0.8 * maxHP && !cr.IsDead() ) {
			switch (i) {
				case BP_TORSO_HP:
					if( roll == 0 ){map.PlaySound ("head_damage1.ogg", cr.HexX, cr.HexY, 1 );}
					if( roll == 1 ){map.PlaySound ("head_damage2.ogg", cr.HexX, cr.HexY, 1 );}
					roll = -1;
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "Ваш корпус болит просто невыносимо.");
					if( cr.StatBase[ ST_BODY_TYPE ] == BT_ROBOT ) cr.Say (SAY_EMOTE, "Корпус искрит");
					if( cr.StatBase[ ST_BODY_TYPE ] == BT_ROBOT ) cr.Say (SAY_NETMSG, "###КРИТИЧЕСКИЕ ПОВРЕЖДЕНИЯ КОРПУСА. ТРЕБУЕТСЯ РЕМОНТ.###");
					if (cr.ParamBase [ST_CURRENT_HP] > maxHP - __DeadHitPoints - currentHP && cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.ParamBase [ST_CURRENT_HP] = maxHP - __DeadHitPoints - currentHP;
					if( screen == false ) FlushScreen( cr, 0, COLOR_RED, 10000 );
					if( screen == false ) FlushScreen( cr, COLOR_RED, 0, 10000 ); 
					screen == true;
					break;
				case BP_HEAD_HP:
					if( roll == 0 ){map.PlaySound ("head_damage1.ogg", cr.HexX, cr.HexY, 1 );}
					if( roll == 1 ){map.PlaySound ("head_damage2.ogg", cr.HexX, cr.HexY, 1 );}
					roll = -1;
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "Ваша голова в ужасном состоянии. В глазах темнеет, вы почти теряете сознание.");
					if( cr.StatBase[ ST_BODY_TYPE ] == BT_ROBOT ) cr.Say (SAY_NETMSG, "###КРИТИЧЕСКИЕ ПОВРЕЖДЕНИЯ ПРОЦЕССОРА. ТРЕБУЕТСЯ РЕМОНТ.###");
					FlushScreen( cr, 0, COLOR_BLACK, 13000 );
					if ( (Random (0, 1) == 0) && !cr.IsKnockout() && !cr.IsDead() ) {
						cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), Random( 18, 25 ), cr.HexX, cr.HexY );
						cr.Say (SAY_EMOTE, "Шатаясь, падает на землю");
						if( screen == false ) FlushScreen( cr, 0, COLOR_BLACK, 10000 );
						if( screen == false ) FlushScreen( cr, COLOR_BLACK, 0, 10000 );
						screen == true;
					}
					else if( (Random (0, 1) == 1) && !cr.IsKnockout() && !cr.IsDead() ) {
						cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), Random( 10, 15 ), cr.HexX, cr.HexY );
						cr.Say (SAY_EMOTE, "Шатается");
						if( screen == false ) FlushScreen( cr, 0, COLOR_BLACK, 10000 );
						if( screen == false ) FlushScreen( cr, COLOR_BLACK, 0, 10000 );
						screen == true;
					}
					if (cr.ParamBase [ST_CURRENT_HP] > maxHP - __DeadHitPoints - currentHP && cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.ParamBase [ST_CURRENT_HP] = maxHP - __DeadHitPoints - currentHP;
					break;
				case BP_EYES_HP:
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "В глазах все темнеет...");
					if( cr.StatBase[ ST_BODY_TYPE ] == BT_ROBOT ) cr.Say (SAY_NETMSG, "###КРИТИЧЕСКИЕ ПОВРЕЖДЕНИЯ СЕНСОРОВ. ТРЕБУЕТСЯ РЕМОНТ.###");
					FlushScreen( cr, 0, COLOR_BLACK, 10000 );
					FlushScreen( cr, COLOR_BLACK, 0, 10000 );
					screen == true;
					if( cr.IsRuning ) {
						cr.Say (SAY_EMOTE, "Валится на бегу");
						cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), Random( 18, 25 ), cr.HexX, cr.HexY );
						FlushScreen( cr, 0, COLOR_RED, 10000 );
						FlushScreen( cr, COLOR_RED, 0, 10000 );
						
					}
					break;
				case BP_RIGHT_ARM_HP:
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "Ваша правая рука ужасно болит.");
					if (cr.ParamBase [ST_CURRENT_HP] >= 0 ) cr.ParamBase [ST_CURRENT_HP] -= Random( 2, 7 );
					if( screen == false ) FlushScreen( cr, 0, COLOR_RED, 10000 );
					if( screen == false ) FlushScreen( cr, COLOR_RED, 0, 10000 );
					break;
				case BP_LEFT_ARM_HP:
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "Ваша левая рука ужасно болит.");
					if (cr.ParamBase [ST_CURRENT_HP] >= 0 ) cr.ParamBase [ST_CURRENT_HP] -= Random( 2, 7 );
					if( screen == false ) FlushScreen( cr, 0, COLOR_RED, 10000 );
					if( screen == false ) FlushScreen( cr, COLOR_RED, 0, 10000 );
					screen == true;
					break;
				case BP_LEFT_LEG_HP:
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "Ваша левая нога ужасно болит.");
					if (cr.ParamBase [ST_CURRENT_HP] >= 0 ) cr.ParamBase [ST_CURRENT_HP] -= Random( 2, 7 );
					if( cr.IsRuning ) cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), Random( 12, 20 ), cr.HexX, cr.HexY );
					if( screen == false ) FlushScreen( cr, 0, COLOR_RED, 10000 );
					if( screen == false ) FlushScreen( cr, COLOR_RED, 0, 10000 );
					screen == true;
					break;
				case BP_RIGHT_LEG_HP:
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "Ваша правая нога ужасно болит.");
					if (cr.ParamBase [ST_CURRENT_HP] >= 0 ) cr.ParamBase [ST_CURRENT_HP] -= Random( 2, 7 );
					if( cr.IsRuning ) cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), Random( 12, 20 ), cr.HexX, cr.HexY );
					if( screen == false ) FlushScreen( cr, 0, COLOR_RED, 10000 );
					if( screen == false ) FlushScreen( cr, COLOR_RED, 0, 10000 );
					screen == true;
					break;
			}
		}
		else if ( currentHP > 0.6 * maxHP && !cr.IsDead() ) {
			switch (i) {
				case BP_TORSO_HP:
					if( roll == 0 ){map.PlaySound ("head_damage1.ogg", cr.HexX, cr.HexY, 1 );}
					if( roll == 1 ){map.PlaySound ("head_damage2.ogg", cr.HexX, cr.HexY, 1 );}
					roll = -1;
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say(SAY_NETMSG, "Вы чувствуете сильную боль в груди.");
					if( cr.StatBase[ ST_BODY_TYPE ] == BT_ROBOT ) cr.Say (SAY_NETMSG, "###ЗНАЧИТЕЛЬНЫЕ ПОВРЕЖДЕНИЯ КОРПУСА. ТРЕБУЕТСЯ РЕМОНТ.###");
					if( cr.StatBase[ ST_BODY_TYPE ] == BT_ROBOT ) cr.Say (SAY_EMOTE, "Корпус искрит");
					if (cr.ParamBase [ST_CURRENT_HP] > maxHP - __DeadHitPoints - currentHP && cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.ParamBase [ST_CURRENT_HP] = maxHP - __DeadHitPoints - currentHP;
					if( cr.IsRuning ) cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), Random( 5, 12 ), cr.HexX, cr.HexY );
					if( screen == false ) FlushScreen( cr, 0, COLOR_RED, 8000 );
					if( screen == false ) FlushScreen( cr, COLOR_RED, 0, 8000 );
					screen == true;
					break;
				case BP_HEAD_HP:
					if( roll == 0 ){map.PlaySound ("head_damage1.ogg", cr.HexX, cr.HexY, 1 );}
					if( roll == 1 ){map.PlaySound ("head_damage2.ogg", cr.HexX, cr.HexY, 1 );}
					roll = -1;
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "У вас кружится и болит голова.");
					if( cr.StatBase[ ST_BODY_TYPE ] == BT_ROBOT ) cr.Say (SAY_NETMSG, "###ЗНАЧИТЕЛЬНЫЕ ПОВРЕЖДЕНИЯ ПРОЦЕССОРА. ТРЕБУЕТСЯ РЕМОНТ.###");
					if (!emoteSaid && !cr.IsKnockout() && !cr.IsDead() ) cr.Say (SAY_EMOTE, "Шатается");
					emoteSaid = true;
					if( screen == false ) FlushScreen( cr, 0, COLOR_RED, 8000 );
					if( screen == false ) FlushScreen( cr, COLOR_RED, 0, 8000 );
					screen == true;
					if (cr.ParamBase [ST_CURRENT_HP] > maxHP - __DeadHitPoints - currentHP && cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.ParamBase [ST_CURRENT_HP] = maxHP - __DeadHitPoints - currentHP;
					if( cr.IsRuning ) cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), Random( 10, 15 ), cr.HexX, cr.HexY );
					cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), Random( 7, 12 ), cr.HexX, cr.HexY );
					break;
				case BP_EYES_HP:
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "В глазах все темнеет...");
					if( cr.StatBase[ ST_BODY_TYPE ] == BT_ROBOT ) cr.Say (SAY_NETMSG, "###ЗНАЧИТЕЛЬНЫЕ ПОВРЕЖДЕНИЯ СЕНСОРОВ. ТРЕБУЕТСЯ РЕМОНТ.###");
					if( screen == false ) FlushScreen( cr, 0, COLOR_BLACK, 10000 );
					if( screen == false ) FlushScreen( cr, COLOR_BLACK, 0, 10000 );
					screen == true;
					break;
				case BP_RIGHT_ARM_HP:
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "Ваша правая рука болит.");
					if (cr.ParamBase [ST_CURRENT_HP] >= 0 ) cr.ParamBase [ST_CURRENT_HP] -= Random( 1, 5 );
					if( screen == false ) FlushScreen( cr, 0, COLOR_RED, 8000 );
					if( screen == false ) FlushScreen( cr, COLOR_RED, 0, 8000 );
					screen == true;
					break;
				case BP_LEFT_ARM_HP:
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "Ваша левая рука болит.");
					if (cr.ParamBase [ST_CURRENT_HP] >= 0 ) cr.ParamBase [ST_CURRENT_HP] -= Random( 1, 5 );
					if( screen == false ) FlushScreen( cr, 0, COLOR_RED, 8000 );
					if( screen == false ) FlushScreen( cr, COLOR_RED, 0, 8000 );
					screen == true;
					break;
				case BP_LEFT_LEG_HP:
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "Ваша левая нога болит.");
					if (cr.ParamBase [ST_CURRENT_HP] >= 0 ) cr.ParamBase [ST_CURRENT_HP] -= Random( 1, 5 );
					if( cr.IsRuning ) cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), Random( 3, 8 ), cr.HexX, cr.HexY );
					if( screen == false ) FlushScreen( cr, 0, COLOR_RED, 8000 );
					if( screen == false ) FlushScreen( cr, COLOR_RED, 0, 8000 );
					screen == true;
					break;
				case BP_RIGHT_LEG_HP:
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "Ваша правая нога болит.");
					if (cr.ParamBase [ST_CURRENT_HP] >= 0 ) cr.ParamBase [ST_CURRENT_HP] -= Random( 1, 5 );
					if( cr.IsRuning ) cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), Random( 3, 8 ), cr.HexX, cr.HexY );
					if( screen == false ) FlushScreen( cr, 0, COLOR_RED, 8000 );
					if( screen == false ) FlushScreen( cr, COLOR_RED, 0, 8000 );
					screen == true;
					break;
			}
		}
		else if ( currentHP > 0.4 * maxHP && !cr.IsDead() ) {
			switch (i) {
				case BP_TORSO_HP:
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "Вы ощущаете боль в груди.");
					if( cr.StatBase[ ST_BODY_TYPE ] == BT_ROBOT ) cr.Say (SAY_NETMSG, "###КОРПУС ПОВРЕЖДЕН. ТРЕБУЕТСЯ РЕМОНТ.###");
					if (cr.ParamBase [ST_CURRENT_HP] > maxHP - __DeadHitPoints - currentHP && cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.ParamBase [ST_CURRENT_HP] = maxHP - __DeadHitPoints - currentHP;
					if( cr.IsRuning ) cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), Random( 4, 8 ), cr.HexX, cr.HexY );
					if( screen == false ) FlushScreen( cr, 0, COLOR_RED, 5000 );
					if( screen == false ) FlushScreen( cr, COLOR_RED, 0, 5000 );
					screen == true;
					break;
				case BP_HEAD_HP:
					map.PlaySound ("head_damage1.ogg", cr.HexX, cr.HexY, 1 );
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "У вас легкое головокружение");
					if( cr.StatBase[ ST_BODY_TYPE ] == BT_ROBOT ) cr.Say (SAY_NETMSG, "###ПРОЦЕССОР ПОВРЕЖДЕН. ТРЕБУЕТСЯ РЕМОНТ.###");
					if (cr.ParamBase [ST_CURRENT_HP] > maxHP - __DeadHitPoints - currentHP && cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.ParamBase [ST_CURRENT_HP] = maxHP - __DeadHitPoints - currentHP;
					if (!emoteSaid && !cr.IsKnockout() && !cr.IsDead() ) cr.Say (SAY_EMOTE, "Шатается");
					emoteSaid = true;
					if( screen == false ) FlushScreen( cr, 0, COLOR_WHITE, 5000 );
					if( screen == false ) FlushScreen( cr, COLOR_WHITE, 0, 5000 );
					screen == true;
					if( cr.IsRuning ) cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), Random( 4, 8 ), cr.HexX, cr.HexY );
					break;
				case BP_EYES_HP:
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "В глазах все мутнеет...");
					if( cr.StatBase[ ST_BODY_TYPE ] == BT_ROBOT ) cr.Say (SAY_NETMSG, "###СЕНСОРЫ ПОВРЕЖДЕНЫ. ТРЕБУЕТСЯ РЕМОНТ.###");
					if( screen == false ) FlushScreen( cr, 0, COLOR_BLACK, 10000 );
					if( screen == false ) FlushScreen( cr, COLOR_BLACK, 0, 10000 );
					screen == true;
					break;
				case BP_RIGHT_ARM_HP:
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "Ваша правая рука побаливает.");
					if (cr.ParamBase [ST_CURRENT_HP] >= 0 ) cr.ParamBase [ST_CURRENT_HP] -= Random( 0, 1 );
					if( screen == false ) FlushScreen( cr, 0, COLOR_RED, 5000 );
					if( screen == false ) FlushScreen( cr, COLOR_RED, 0, 5000 );
					screen == true;
					break;
				case BP_LEFT_ARM_HP:
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "Ваша левая рука побаливает.");
					if (cr.ParamBase [ST_CURRENT_HP] >= 0 ) cr.ParamBase [ST_CURRENT_HP] -= Random( 0, 1 );
					if( screen == false ) FlushScreen( cr, 0, COLOR_RED, 5000 );
					if( screen == false ) FlushScreen( cr, COLOR_RED, 0, 5000 );
					screen == true;
					break;
				case BP_LEFT_LEG_HP:
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "Ваша левая нога побаливает.");
					if (cr.ParamBase [ST_CURRENT_HP] >= 0 ) cr.ParamBase [ST_CURRENT_HP] -= Random( 0, 1 );
					if( cr.IsRuning ) cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), Random( 2, 4 ), cr.HexX, cr.HexY );
					if( screen == false ) FlushScreen( cr, 0, COLOR_RED, 5000 );
					if( screen == false ) FlushScreen( cr, COLOR_RED, 0, 5000 );
					screen == true;
					break;
				case BP_RIGHT_LEG_HP:
					if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.Say (SAY_NETMSG, "Ваша правая нога побаливает.");
					if (cr.ParamBase [ST_CURRENT_HP] >= 0 ) cr.ParamBase [ST_CURRENT_HP] -= Random( 0, 1 );
					if( cr.IsRuning ) cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), Random( 2, 4 ), cr.HexX, cr.HexY );
					if( screen == false ) FlushScreen( cr, 0, COLOR_RED, 5000 );
					if( screen == false ) FlushScreen( cr, COLOR_RED, 0, 5000 );
					screen == true;
					break;
			}
		}
		else if (currentHP > 0.2 * maxHP && !cr.IsDead() ) {
			if (cr.ParamBase [ST_CURRENT_HP] > maxHP - __DeadHitPoints - currentHP && cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT ) cr.ParamBase [ST_CURRENT_HP] = maxHP - __DeadHitPoints - currentHP;
		}
		if (cr.StatBase [ST_BODY_TYPE] != BT_ROBOT) {
			if ((currentHP < 0.2 * maxHP) && (currentHP > 0)) cr.ParamBase [i] -= cr.Stat [ST_HEALING_RATE];
			else if ((currentHP < 0.3 * maxHP) && (currentHP > 0)) cr.ParamBase [i] -= cr.Stat [ST_HEALING_RATE]*0.8;
			else if ((currentHP < 0.4 * maxHP) && (currentHP > 0)) cr.ParamBase [i] -= cr.Stat [ST_HEALING_RATE]*0.6;
			else if ((currentHP < 0.5 * maxHP) && (currentHP > 0)) cr.ParamBase [i] -= cr.Stat [ST_HEALING_RATE]*0.4;
			else if ((currentHP < 0.6 * maxHP) && (currentHP > 0)) cr.ParamBase [i] -= cr.Stat [ST_HEALING_RATE]*0.2;
			else if ((currentHP < 0.7 * maxHP) && (currentHP > 0)) cr.ParamBase [i] -= cr.Stat [ST_HEALING_RATE]*0.1;
		}
		if (currentHP > maxHP - __DeadHitPoints && cr.StatBase [ST_BODY_TYPE] != BT_ROBOT  ) cr.ParamBase [i] = maxHP - __DeadHitPoints;
		if (currentHP < 0) cr.ParamBase [i] = 0;
		i ++;
	}
	return ( 4 * 60 * __TimeMultiplier);
	*/
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on player register/login in game or npc created/loaded.
// Default start position for players is center of global map.
void critter_init( Critter& cr, bool firstTime )
{
	if( cr.IsPlayer() && !SetCritterApRegen(cr) )
		Log( "SetCritterApRegen( " + cr.Id + ") failed!" );
	
	if( firstTime )
    {
	
        if( cr.IsPlayer() )
        {
            AddNewCritterHistoryBase( cr );                             // pm menu
            GameVar@ TotalPlayers = GetGlobalVar( GVAR_total_players ); // общее число персонажей
            if( TotalPlayers.GetValue() < int( cr.Id ) )
                TotalPlayers.opAssign( cr.Id );
            // Input: 7 special, 3 tag skills, 2 traits, age, gender
            uint traits = 0;
            for( uint i = TRAIT_BEGIN; i <= TRAIT_END; i++ )
            {
                if( cr.TraitBase[ i ] != 0 && traits < 2 )
                {
                    cr.TraitBase[ i ] = 1;
                    traits++;
                }
                else
                    cr.TraitBase[ i ] = 0;
            }

            if( cr.StatBase[ ST_GENDER ] < 0 || cr.StatBase[ ST_GENDER ] > 1 )
                cr.StatBase[ ST_GENDER ] = 0;
            if( cr.StatBase[ ST_AGE ] < 14 || cr.StatBase[ ST_AGE ] > 80 )
                cr.StatBase[ ST_AGE ] = 25;
            for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
                cr.StatBase[ i ] = CLAMP( cr.StatBase[ i ], 1, 10 );

            if( ( cr.StatBase[ ST_STRENGTH ] + cr.StatBase[ ST_PERCEPTION ] + cr.StatBase[ ST_ENDURANCE ] +
                  cr.StatBase[ ST_CHARISMA ] + cr.StatBase[ ST_INTELLECT ] + cr.StatBase[ ST_AGILITY ] + cr.StatBase[ ST_LUCK ] ) != __StartSpecialPoints )
            {
                for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
                    cr.StatBase[ i ] = 5;
            }

            cr.StatBase[ ST_EMP_RESIST ] = 500;
            // cr.AddHolodiskInfo(42); // Journalist's research

            // Default skin
            #ifdef PLAYERS_3D
            if( cr.StatBase[ ST_GENDER ] == GENDER_MALE )
            {
                cr.StatBase[ ST_BASE_CRTYPE ] = CLAMP( cr.StatBase[ ST_BASE_CRTYPE ], CRTYPE_3D_MALE_NORMAL, CRTYPE_3D_MALE_FAT );
                cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_HAIR ] = CLAMP( cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_HAIR ], 0, ATTRIBUTE_Hair_Male_Shoulder + ATTRIBUTE_COLOR_RedGrey );
                if( cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_MUSTACHE ] != ATTRIBUTE_Mustache_MadMax )
                    cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_MUSTACHE ] = CLAMP( cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_MUSTACHE ], 0, ATTRIBUTE_Mustache_Male_Stubble + ATTRIBUTE_COLOR_RedGrey );
                cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_BEARD ] = CLAMP( cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_BEARD ], 0, ATTRIBUTE_Beard_Male_Stubble + ATTRIBUTE_COLOR_RedGrey );
            }
            else
            {
                cr.StatBase[ ST_BASE_CRTYPE ] = CLAMP( cr.StatBase[ ST_BASE_CRTYPE ], CRTYPE_3D_FEMALE_NORMAL, CRTYPE_3D_FEMALE_FAT );
                cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_HAIR ] = CLAMP( cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_HAIR ], 0, ATTRIBUTE_Hair_Female_Short + ATTRIBUTE_COLOR_RedGrey );
                if( cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_MUSTACHE ] != ATTRIBUTE_Mustache_MadMax )
                    cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_MUSTACHE ] = 0;
                cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_BEARD ] = 0;
            }

            cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_SKIN ] = CLAMP( cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_SKIN ], ATTRIBUTE_Skin_Human_White01, ATTRIBUTE_Skin_Human_Yellow03 );
            cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_PONYTAIL ] = CLAMP( cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_PONYTAIL ], 0, ATTRIBUTE_Ponytail_Ponytail2 + ATTRIBUTE_COLOR_RedGrey );
            cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_ARMLET ] = ATTRIBUTE_Armlet_PipBoyClosed;

            cr.ChangeCrType( cr.StatBase[ ST_BASE_CRTYPE ] );
            #endif
            #ifndef PLAYERS_3D
            cr.ChangeCrType( cr.Stat[ ST_GENDER ] == GENDER_MALE ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F );
            cr.StatBase[ ST_BASE_CRTYPE ] = cr.CrType;
            #endif
        }

        if( cr.TagSkill[ TAG_SKILL1 ] < int(SKILL_BEGIN) || cr.TagSkill[ TAG_SKILL1 ] > int(SKILL_END) )
            cr.TagSkillBase[ TAG_SKILL1 ] = 0;
        if( cr.TagSkill[ TAG_SKILL2 ] < int(SKILL_BEGIN) || cr.TagSkill[ TAG_SKILL2 ] > int(SKILL_END) )
            cr.TagSkillBase[ TAG_SKILL2 ] = 0;
        if( cr.TagSkill[ TAG_SKILL3 ] < int(SKILL_BEGIN) || cr.TagSkill[ TAG_SKILL3 ] > int(SKILL_END) )
            cr.TagSkillBase[ TAG_SKILL3 ] = 0;
        if( cr.TagSkill[ TAG_SKILL1 ] == cr.TagSkill[ TAG_SKILL2 ] )
            cr.TagSkillBase[ TAG_SKILL1 ] = 0;
        if( cr.TagSkill[ TAG_SKILL2 ] == cr.TagSkill[ TAG_SKILL3 ] )
            cr.TagSkillBase[ TAG_SKILL2 ] = 0;
        if( cr.TagSkill[ TAG_SKILL3 ] == cr.TagSkill[ TAG_SKILL1 ] )
            cr.TagSkillBase[ TAG_SKILL3 ] = 0;

        CritterGenerate( cr );
        cr.StatBase[ ST_CURRENT_HP ] = cr.Stat[ ST_MAX_LIFE ];
        
        //Kriegwolf: устанавливаем хп частей тела и ивент
        
		/*
        cr.ParamBase [BP_HEAD_HP] = 0;
        cr.ParamBase [BP_EYES_HP] = 0;
        cr.ParamBase [BP_GROIN_HP] = 0;
        cr.ParamBase [BP_TORSO_HP] = 0;
        cr.ParamBase [BP_LEFT_ARM_HP] = 0;
        cr.ParamBase [BP_RIGHT_ARM_HP] = 0;
        cr.ParamBase [BP_LEFT_LEG_HP] = 0;
        cr.ParamBase [BP_RIGHT_LEG_HP] = 0;
        
        cr.ParamBase [TRAUMA_PLUGIN_WORKING] = 1;
        cr.AddTimeEvent( "cte_limb_management",  0, CTE_LIMB_MANAGEMENT);
        //Kriegwolf: Закончили
		*/
        
        //Kriegwolf: ивент браминотраха
        if (cr.Stat [ST_BASE_CRTYPE] == 15) brahminInitSearch (cr);

        cr.StatBase[ ST_CURRENT_AP ] = cr.Stat[ ST_ACTION_POINTS ] * 100;

        for(int i=REPUTATION_BEGIN;i<=599;i++) cr.ParamBase[i]=int(0x80000000); // 599 is last number processed in client

        if( cr.IsPlayer() )
        {
            for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
                cr.StatBase[ i ] = CLAMP( cr.StatBase[ i ], 1, 10 );

            cr.StatBase[ ST_REPLICATION_COST ] = 100;
            cr.StatBase[ ST_REPLICATION_MONEY ] = 0;
            cr.StatBase[ ST_REPLICATION_COUNT ] = 0;
            cr.StatBase[ ST_TEAM_ID ] = 1;
            cr.StatBase[ ST_DAMAGE_TYPE ] = DAMAGE_NORMAL;


            skin( cr, cr.StatBase[ ST_BODY_TYPE ] );
            cr.StatBase[ ST_BODY_TYPE ] = 0;

        }
        else
        {
            cr.ChangeCrType( cr.StatBase[ ST_BASE_CRTYPE ] );
            if( cr.Stat[ ST_LEVEL ] != 0 )
                NpcProcessLevel( cr );
        }
    }
    else
    {
        if( cr.IsPlayer() ) {
            CheckFaction( cr, true );                      // add character to FACTION
        }


        // Main quest
        // if(cr.IsPlayer() && __MainStoryLineActive) SetPlayerStoryLineLocation(cr);

        // Current skin validation
        Item@ armor = cr.GetItem( 0, SLOT_ARMOR );
        if( cr.Stat[ ST_BASE_CRTYPE ] == 0 )
            cr.StatBase[ ST_BASE_CRTYPE ] = ( cr.Stat[ ST_GENDER ] == GENDER_MALE ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F );
        if( not valid( armor ) )
        {
            uint crType = cr.Stat[ ST_BASE_CRTYPE ];
            if( crType == 0 )
                crType = ( cr.Stat[ ST_GENDER ] == GENDER_MALE ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F );
            cr.StatBase[ ST_BASE_CRTYPE ] = crType;
            if( cr.CrType != crType )
                cr.ChangeCrType( crType );
        }

        if( cr.IsPlayer() ) RestartHair( cr );
        
		if (cr.Stat [ST_BASE_CRTYPE] == 15) brahminInitSearch (cr);
		/*
        cr.EraseTimeEvents (CTE_LIMB_MANAGEMENT);
      	cr.AddTimeEvent( "cte_limb_management",  0, CTE_LIMB_MANAGEMENT);
		*/
        
        // Armor perk validation
        if( not valid( armor ) && cr.Stat[ ST_CURRENT_ARMOR_PERK ] != 0 )
        {
            switch( cr.Stat[ ST_CURRENT_ARMOR_PERK ] )
            {
            case ARMOR_PERK_POWERED:
                cr.StatBase[ ST_STRENGTH_EXT ] -= 3;
                cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 30;
                break;
            case ARMOR_PERK_COMBAT:
                cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 20;
                break;
            case ARMOR_PERK_ADVANCED_I:
                cr.StatBase[ ST_STRENGTH_EXT ] -= 4;
                cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 60;
                break;
            case ARMOR_PERK_ADVANCED_II:
                cr.StatBase[ ST_STRENGTH_EXT ] -= 4;
                cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 75;
                break;
            case ARMOR_PERK_CHARISMA:
                cr.StatBase[ ST_CHARISMA_EXT ] -= 1;
                break;
            case ARMOR_PERK_ANTIRAD:
                cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 70;
                break;				
			default:
                break;
            }
            cr.StatBase[ ST_CURRENT_ARMOR_PERK ] = 0;
        }
        // Head Item Perk validation
		Item@ head_item = cr.GetItem( 0, SLOT_HEAD );
        if( not valid( head_item ) && cr.Stat[ ST_CURRENT_HEAD_ITEM_PERK ] != 0 )
        {
            switch( cr.Stat[ ST_CURRENT_HEAD_ITEM_PERK ] )
            {
				case HEAD_PERK_COOL:
					cr.StatBase[ ST_CHARISMA_EXT ] -= 1;
					break;
				case HEAD_PERK_GLASSES:
					if( cr.StatBase[ ST_PERCEPTION_EXT ] >= 2 )
					{
						cr.StatBase[ ST_PERCEPTION_EXT ] -= 2;
					}
					break;
				case HEAD_PERK_VERY_COOL:
					cr.StatBase[ ST_CHARISMA_EXT ] -= 2;
					break;
				case HEAD_PERK_LUCKY_CHARM:
					cr.StatBase[ ST_LUCK_EXT ] -= 1;
					break;
				case HEAD_PERK_COOL_LUCKY_CHARM:
					cr.StatBase[ ST_CHARISMA_EXT ] -= 1;
					cr.StatBase[ ST_LUCK_EXT ] -= 1;
					break;
				case HEAD_PERK_COOL_GLASSES:
					if( cr.StatBase[ ST_PERCEPTION_EXT ] >= 2 )
					{
						cr.StatBase[ ST_PERCEPTION_EXT ] -= 2;
						cr.StatBase[ ST_CHARISMA_EXT ] -= 1;
					}
					break;
            }
            cr.StatBase[ ST_CURRENT_HEAD_ITEM_PERK ] = 0;
		}

        // Clear timeouts if too long (happens when saves got removed)
        for( uint i = TIMEOUT_BEGIN; i <= TIMEOUT_END; i++ )
            if( i != TO_BATTLE && cr.Timeout[ i ] > int(MAXIMUM_TIMEOUT) )
                cr.TimeoutBase[ i ] = __FullSecond;

        // Erase zero time events
        cr.EraseTimeEvents( 0 );
    }

    if( cr.IsPlayer() && cr.StatBase[ ST_STUDY_EXP_MAX ] < 10000 )
    {
        cr.StatBase[ ST_STUDY_EXP_MAX ] = 10000;
    }
	
	if( cr.IsPlayer() ) {
		cr.ModeBase[ MODE_HIDE ] = 0; //Убираем скрытность ГМскую, анурянскую.
		cr.StatBase[ ST_UNSPENT_PERKS ] = 0; //Обнуляем, временная мера.
	}

	if (cr.Stat [ST_BASE_CRTYPE] == 81 && _CritCountItem( cr, PID_FIRE_GECKO_FLAME_WEAPON ) == 0 ) 
		cr.AddItem( PID_FIRE_GECKO_FLAME_WEAPON, 1 );
        
    ChangeCritterSpeed( cr );

    manager_critter_init( cr, firstTime );

    DllCritterInit(cr, firstTime);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on critter exit from game.
void critter_finish( Critter& cr, bool toDelete )
{
    if( cr.IsPlayer() )                     // add 22.10.10 //flare
    {
        CheckFaction( cr, false );          // discord character from FACTION
        //cr.StatBase[ ST_ACCESS_LEVEL ] = 0; // pm added
    }
    if( toDelete && cr.Stat[ ST_DEAD_BLOCKER_ID ] != 0 )
    {
        Item@ block = ::GetItem( cr.Stat[ ST_DEAD_BLOCKER_ID ] );
        if( valid( block ) )
            DeleteItem( block );
        cr.StatBase[ ST_DEAD_BLOCKER_ID ] = 0;
    }
    // if(toDelete) DeleteVars(cr.Id); used engine vars garbager

    manager_critter_finish( cr, toDelete );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call every __CritterIdleTick time.
void CritSFX( Critter& cr )
{
/*
	Map@ map = cr.GetMap();
	if( !valid(map) ) return;
	
	Critter@[] source = { cr };
    Critter@[] seeing, hearing;
	map.GetCrittersSeeing( source, true, FIND_ALL | FIND_ONLY_PLAYERS, seeing );
	map.GetCrittersHex( cr.HexX, cr.HexY, 20, FIND_ALL | FIND_ONLY_PLAYERS, hearing );
	
	for( uint i = 0; i < hearing.length(); i++ )
	{
		for( uint j = 0; j < seeing.length(); j++ )
		{
			if( valid( hearing[i] ) && valid( seeing[j] ) && hearing[i].Id == seeing[j].Id )
			{
				if( hearing[i].Id == cr.Id ) continue;
				hearing[i].Say( SAY_EMOTE, "слышит" );
				@hearing[i] = null;
				//seeing[i].Say( SAY_EMOTE, "видит" );
				@seeing[i] = null;
				break;
			}
		}
		if( valid( hearing[i] ) )
			hearing[ i ].RunClientScript( "rp_client@__HearSound", cr.HexX, cr.HexY, 0, "!!!", null );
	}
/*
	//crits[ i ].RunClientScript( "rp_client@__HearSound", cr.HexX, cr.HexY, 0, null, null );
	//GetCrittersHex 
    

    if( @target.GetMap() != null )
    {
        target.GetMap().

        for( int i = 0, j = crits.length(); i < j; i++ )
            if( crits[ i ].Id != target.Id )
                AddEff( crits[ i ], sendEff, results );
    }

	//***
	if( cr.IsRuning && ( cr.ParamBase[ CR_HEXX ] != cr.HexX || cr.ParamBase[ CR_HEXY ] != cr.HexY ) )
	{
		Map@ map = cr.GetMap();
		if(valid(map))
		{
			
		}
		cr.ParamBase[ CR_HEXX ] = cr.HexX;
		cr.ParamBase[ CR_HEXY ] = cr.HexY;
		
		string sound = "шум";
		uint[] loud_armors = {
			PID_METAL_ARMOR, PID_METAL_ARMOR_MK_II, PID_TESLA_ARMOR, PID_POLICE_ARMOR, PID_COMBAT_ARMOR, PID_COMBAT_ARMOR_MK_II, PID_BROTHERHOOD_COMBAT_ARMOR, PID_BLACK_COMBAT_ARMOR 
		};
		
        Item@ armor = cr.GetItem( 0, SLOT_ARMOR ); //ПАшки и АПАшки с экзоскелетами пока не считаются.
        if( cr.Stat[ ST_BASE_CRTYPE ] == BT_ROBOT || ( valid(armor) && loud_armors.find(armor.GetProtoId()) != -1 ) )
			sound = "звон";

		if( valid( map ) )
			map.SetText( cr.HexX, cr.HexY, COLOR_LGRAY, ":" + sound + ":" );
	}*/
}

void CritterRegen( Critter& cr )
{
	if( cr.IsDead() ) return;
	
    if( cr.Stat[ ST_BODY_TYPE ] != BT_ROBOT )
	{
		if( cr.Timeout[ TO_HEALING ] == 0 )
		{
			cr.TimeoutBase[ TO_HEALING ] = __FullSecond + REAL_MINUTE( cr.IsKnockout() ? 2 : 4 );
			if( cr.Mode[ MODE_NO_HEAL ] != 0 || cr.StatBase[ ST_CURRENT_HP ] == cr.Stat[ ST_MAX_LIFE ] ) return;

			int regen = cr.Stat[ ST_HEALING_RATE ], penalty = 0;
			if( FLAG( cr.StatBase[ ST_CRSTATUS ], CR_STATUS_BULLET_OVER ) ) penalty += 5;
			if( FLAG( cr.StatBase[ ST_CRSTATUS ], CR_STATUS_HEAVY_DMG ) )  penalty += 5;
			regen = CLAMP( regen * ( 10 - penalty ) / 10, 1, regen ); //минимальный реген - 1 хп
			if( cr.Param[ QST_GAMEMODE ] == GAME_TEST )
				cr.Say( SAY_NETMSG, "Вы отрегенили " + regen + " ХП." );
            cr.StatBase[ ST_CURRENT_HP ] += regen; //Итоговый реген 50% при одной из двух травм, и 0% при обеих.

            if( cr.StatBase[ ST_CURRENT_HP ] > cr.Stat[ ST_MAX_LIFE ] )
                cr.StatBase[ ST_CURRENT_HP ] = cr.Stat[ ST_MAX_LIFE ];
			else
			{
				if( !cr.IsKnockout() )
				{
					cr.StatBase[ ST_HUNGER ] -= Random( 1, 1 + regen / 5 );
					cr.StatBase[ ST_THIRST ] -= Random( 1, 1 + regen / 5 );
				}
			}
		}
	}
}

void StaminaRegen( Critter& cr )
{
    if( !cr.IsPlayer() ) return;

	if( cr.StatBase[ ST_STAMINA ] < ( cr.StatBase[ ST_CURRENT_HP ] + 50 ) ) 
		cr.StatBase[ ST_STAMINA ] ++;
		
	GameVar@ weariness = GetLocalVar( LVAR_weariness, cr.Id );
	if( weariness > 0 )
		weariness.opAddAssign( Random( -1, -2 ) );

	if( cr.ParamBase[ ST_VAR5 ] > 0 )
		cr.ParamBase[ ST_VAR5 ] -= 1;

	if( uint( cr.Param[ ST_QMAP ] ) == 0 )
	{
		Map@ map = cr.GetMap();
		if( !(map is null) )
			qmap_critter_in( map.Id, cr );
	}
}


void critter_idle( Critter& cr )
{
	//Топот существ.
	//CritSFX( cr );
	
	CritterRegen( cr );
	
	ChangeCritterSpeed( cr );

	StaminaRegen ( cr );
	
    manager_critter_idle( cr );
}

#define EXP_BAR_KILLING_TIME    ( 60 )

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter dies.
// Killer can be null.
void critter_dead( Critter& cr, Critter@ killer )
{
    Map@ map = cr.GetMap();
    if( !valid( map ) )
        Log( "Critter #" + cr.Id + " was killed on global." );

    if( cr.IsNpc() ) cr.DropPlanes();
	
    if( valid( map ) && cr.Mode[ MODE_NO_FLATTEN ] != 0 )
    {
        Item@ blocker = map.AddItem( cr.HexX, cr.HexY, PID_UNVISIBLE_BLOCK, 1 );
        if( valid( blocker ) )
            cr.StatBase[ ST_DEAD_BLOCKER_ID ] = blocker.Id;
    }

    manager_critter_dead( cr, killer );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reswapned.
void critter_respawn( Critter& cr )
{
    cr.TimeoutBase[ TO_REPLICATION ] = 0;
    if( cr.CrType == 115 )
    {
        uint body = cr.Stat[ ST_BASE_CRTYPE ];
        if( body == 0 )
            body = ( cr.Stat[ ST_GENDER ] == GENDER_MALE ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F );
        cr.ChangeCrType( body );
    }
    else if( cr.CrType == 81 )
    {
        Item@ weapon = cr.AddItem( PID_FIREBREATH, 1 );
        cr.MoveItem( weapon.Id, 1, SLOT_HAND1 );
        weapon.Update();
    }
    else if( cr.CrType == 51 || cr.CrType == 60 || cr.CrType == 100 )
    {
        Item@ weapon = cr.AddItem( PID_CLAW_EXT, 1 );
        cr.MoveItem( weapon.Id, 1, SLOT_HAND1 );
        weapon.Update();
    }

    if( cr.Param[ ST_PARALYSIS_LEVEL ] != 0 )
        DropParalysisInstant( cr );                                   // Сбрасываем эффект нейротоксина. TabaK
    if( cr.Param[ ST_POISONING_LEVEL ] != 0 )
        DropPoison( cr );
    if( cr.Param[ ST_RADIATION_LEVEL ] != 0 )
        DropRadiation( cr );

    if( cr.Stat[ ST_DEAD_BLOCKER_ID ] != 0 )
    {
        Item@ block = ::GetItem( cr.Stat[ ST_DEAD_BLOCKER_ID ] );
        if( valid( block ) )
            DeleteItem( block );
        cr.StatBase[ ST_DEAD_BLOCKER_ID ] = 0;
    }

    manager_critter_respawn( cr );
}

// import void RefrashCoords(Critter& cr) from "globalmap_group";
import bool LocIsCity( uint locPid ) from "globalmap_group";

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter in to map.
void map_critter_in( Map& map, Critter& cr )
{
    if( cr.IsPlayer() )
    {
        qmap_critter_in( map.Id, cr );

        uint16 locPid = map.GetLocation().GetProtoId();
        if( LocIsCity( locPid ) )
        {
            GameVar@ lastCityVar = GetLocalVar( LVAR_last_city, cr.Id );
            if( lastCityVar is null )
                return;
            lastCityVar = locPid;
        }
    }

    // RefrashCoords(cr);

    manager_map_critter_in( map, cr );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter out from map.
void map_critter_out( Map& map, Critter& cr )
{
    if( cr.IsPlayer() )
    {
        qmap_critter_out( map.Id, cr );
    }

    manager_map_critter_out( map, cr );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something player votes for another.
// Already checked valid positions and timeout.
void karma_voting( Critter& crFrom, Critter& crTo, bool valUp )
{

}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine visibility of items with ITEM_TRAP flag.
// To start working set flag LOOK_CHECK_SCRIPT to __LookChecks global var.
bool check_trap_look( Map& map, Critter& cr, Item& trap )
{
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine cost of single item.
// To allow function set __CustomItemCost to true.
// Don't forgot specify this function in client script.
uint item_cost( Item& item, Critter& cr, Critter& npc, bool sell )
{
	uint8  itemType = item.GetType();
    uint16 pid = item.GetProtoId();
    float   cost = item.Proto.Cost;

	if( cr.Param[ QST_GAMEMODE ] == GAME_TEST )
		cr.Say( SAY_NETMSG, pid + ": " + cost + "$" );

    if( pid == PID_BOTTLE_CAPS || pid == PID_REAL_BOTTLE_CAPS )
        return 1;
		
	if( pid == PID_DOLLAR_100 )
		return 100;
		
	if( pid == PID_DOLLAR_20 )
		return 20;
		
	if( pid == PID_DOLLAR_5 )
		return 5;

    if( itemType == ITEM_TYPE_ARMOR || itemType == ITEM_TYPE_WEAPON )
    {
        uint8 brokenCount = item.BrokenCount;
        uint8 brokenFlags = item.BrokenFlags;

        if( FLAG( brokenFlags, BI_NOTRESC ) || FLAG( brokenFlags, BI_BROKEN ) )
            cost *= 0.01;
        else if( FLAG( brokenFlags, BI_HIGHBROKEN ) )
            cost /= 3;
        else if( FLAG( brokenFlags, BI_NORMBROKEN ) )
            cost /= 2;
        else if( FLAG( brokenFlags, BI_LOWBROKEN ) )
            cost /= 1.4;
        else if( brokenCount > 0 )
            cost *= brokenCount != 100 ? brokenCount * 0.01 : 0.01;

        if( itemType == ITEM_TYPE_WEAPON && !item.IsStackable() )
        {	
			ProtoItem@ ammo = GetProtoItem( item.AmmoPid );
			if( valid( ammo ) )
				cost += ammo.Cost * item.AmmoCount;
        }
    }
	
	//if( itemType == ITEM_TYPE_PARTIAL ) //TODO: Переделать в новый "тип" предметов (прото) - PARTIAL.
	uint[] partial_pids = { PID_ITSOAP01_PRT, PID_FPSHL6_PRT, PID_CIGARETTES_PRT };
	if( partial_pids.find( pid ) != -1 )
	{
		cost = cost * item.Val0 / 10; //Прямая зависимость от количества оставшихся предметов в "пачке".
	}

	//Торговля мк3 - учитывает опыт НД и ТНФ. Сделал бы отделной ф-ей, да толку - от этой итак ничего не осталось уже.
	
	//Редактируемые "настройки" торговли:
		float skill_range = 150; //Градация разницы в скиллах между НПЦ и чаром. Чем она шире - тем медленней падение/рост цен за 1% разницы.
		
		float price_range = 0.25; //Диапазон разброса цен на покупку у НПЦ.
		//Т.е. это больше НЕ "максимальная допустимая уценка скупки и наценка продажи".

	//Промежуточные функции. Не трогать почём зря!
		//Высчитывает % отношения разницы к допустимому разбросу скиллов. Диапазон: [ -1, 1 ]
			float skill = CLAMP( cr.SkillBase[ SK_BARTER ] - npc.SkillBase[ SK_BARTER ], -skill_range, skill_range ) * ( 1.0 / skill_range ); 

	//Основная логика:
		if( sell ) //Для продажи неписю:
			cost = cost * 0.4; //40% от себеса
		else //Для покупки у НПЦ:
			cost = cost * ( 0.75 - 0.25 * skill ); //От 50 до 100% цены себестоимости товара.
		
	//Конец "торговли".
	
    return CLAMP( floor( cost ), 1, cost );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on barter transaction.
// Return false to cancel transaction.
bool items_barter( Item@[]& saleItems, uint[]& saleItemsCount, Item@[]& buyItems, uint[]& buyItemsCount, Critter& player, Critter& npc )
{
    if( npc.Mode[ MODE_BARTER_ONLY_CASH ] > 0 )
    {
		uint[][] money_tiers = 
		{	{}, //Про запас, пустой.
			{ PID_DOLLAR_100, PID_DOLLAR_20, PID_DOLLAR_5, PID_BOTTLE_CAPS, PID_GOLDEN_COIN },
			{ PID_REAL_BOTTLE_CAPS, PID_MORNING_STAR_MINE, PID_KOKOWEEF_MINE_SCRIP },
		};
        for( uint i = 0, j = saleItems.length(); i < j; i++ )
        {
			bool isOk = false;
            Item@ item = saleItems[ i ];
			uint pid = item.GetProtoId();
			if( !valid( item ) ) continue;
			for( uint k = money_tiers.length() - 1; k > 0; k-- )
				if( money_tiers[k].find( pid ) != -1 )
				{
					if( npc.Mode[ MODE_BARTER_ONLY_CASH ] < int( k ) )
					{
						npc.Say( SAY_NORM_ON_HEAD, "Такую валюту я не принимаю." );
						return false;
					}
					else
					{
						isOk = true;
					}
					break;
				}
			if( !isOk )
			{
				player.Say( SAY_NETMSG, "Только наличные, никакого бартера." );
				return false;
			}
        }
    }
    GameVar@ loan = GetUnicumVar( UVAR_checkLoan, player.Id, npc.Id );
    if( loan == 1 )
    {
        return false;
    }

    ChangeCritterSpeed( player ); // pm added
    ChangeCritterSpeed( npc );    // pm added

    return true;
}


// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something player craft some items.
// Resources have None accessory and will be deleted after this function if no will be added to some place.
void items_crafted( Item@[]& items, uint[]& itemsCount, Item@[]& resources, Critter& crafter )
{
    ChangeCritterSpeed( crafter );   // pm added
    // Find max deterioration value
    int maxDeterioration = 0;
    for( uint i = 0, j = resources.length(); i < j; i++ )
    {
        Item@ item = resources[ i ];
        int   deterioration = GetDeteriorationProcent( item );
        if( deterioration > maxDeterioration )
            maxDeterioration = deterioration;
    }

    for( uint i = 0, j = items.length(); i < j; i++ )
    {
        // Unload weapons
        Item@ item = items[ i ];
        if( item.GetType() == ITEM_TYPE_WEAPON && item.Proto.Weapon_MaxAmmoCount > 0 )
        {
            item.AmmoCount = 0;
            item.Update();
        }

        // Set max deterioration value
        SetDeterioration( item, maxDeterioration );
    }

    uint16 itemsZiroPid = items[ 0 ].GetProtoId();

    if( itemsZiroPid == PID_LOCKER_LOW || itemsZiroPid == PID_LOCKER_MED || itemsZiroPid == PID_LOCKER_HARD )
    {
        items[ 0 ].Val0 = 250 + ABS( ( crafter.SkillBase[ SK_REPAIR ] / 3 ) + ( crafter.SkillBase[ SK_LOCKPICK ] / 2 ) );
        return;
    }

    /*traps
       val6 - count uses
       val5 - dmg type
       val4 - max dmg
       val3 - min dmd*/

    switch( itemsZiroPid )
    {
		case PID_TRAP_FIRE_BREATH: {
			items[ 0 ].Val6 = 2;
			items[ 0 ].Val5 = DAMAGE_FIRE;
			items[ 0 ].Val4 = crafter.SkillBase[ SK_TRAPS ] / 5;
			items[ 0 ].Val3 = crafter.SkillBase[ SK_TRAPS ] / 15;
			items[ 0 ].Val1 = crafter.Id;
			return; }
		case PID_TRAP_ELECTRIC: {
			items[ 0 ].Val6 = 4;
			items[ 0 ].Val5 = DAMAGE_ELECTR;
			items[ 0 ].Val4 = crafter.SkillBase[ SK_TRAPS ] / 5;
			items[ 0 ].Val3 = crafter.SkillBase[ SK_TRAPS ] / 15;
			items[ 0 ].Val1 = crafter.Id;
			return; }
		case PID_TRAP_KNIFES: {
			items[ 0 ].Val6 = 0;
			items[ 0 ].Val5 = DAMAGE_NORMAL;
			items[ 0 ].Val4 = crafter.SkillBase[ SK_TRAPS ] / 10;
			items[ 0 ].Val3 = crafter.SkillBase[ SK_TRAPS ] / 20;
			items[ 0 ].Val1 = crafter.Id;
			return; }
		case PID_TRAP_CANISTER_SHOT: {
			items[ 0 ].Val6 = 0;
			items[ 0 ].Val5 = DAMAGE_NORMAL;
			items[ 0 ].Val4 = 2;
			items[ 0 ].Val3 = 1;
			items[ 0 ].Val1 = crafter.Id;
			return; }
		case PID_TRAP_STUNNER: {
			items[ 0 ].Val6 = 4;
			items[ 0 ].Val5 = DAMAGE_NORMAL;
			items[ 0 ].Val4 = crafter.SkillBase[ SK_TRAPS ] / 20;
			items[ 0 ].Val3 = crafter.SkillBase[ SK_TRAPS ] / 30;
			items[ 0 ].Val1 = crafter.Id;
			return; }
		case PID_TRAP_SLEDGE_HAMMER: {
			items[ 0 ].Val6 = 0;
			items[ 0 ].Val5 = DAMAGE_NORMAL;
			items[ 0 ].Val4 = crafter.SkillBase[ SK_TRAPS ] / 10;
			items[ 0 ].Val3 = crafter.SkillBase[ SK_TRAPS ] / 20;
			items[ 0 ].Val1 = crafter.Id;
			return; }
		case PID_TRAP_POISON_BLADE: {
			items[ 0 ].Val6 = 0;
			items[ 0 ].Val5 = DAMAGE_NORMAL;
			items[ 0 ].Val4 = crafter.SkillBase[ SK_TRAPS ] / 20;
			items[ 0 ].Val3 = crafter.SkillBase[ SK_TRAPS ] / 30;
			items[ 0 ].Val1 = crafter.Id;
			return; }
		case PID_TRAP_ITEM_BREAKER: {
			items[ 0 ].Val6 = 0;
			items[ 0 ].Val5 = DAMAGE_NORMAL;
			items[ 0 ].Val4 = 1;
			items[ 0 ].Val3 = 0;
			items[ 0 ].Val1 = crafter.Id;
			return; }
		case PID_TRAP_STAKE: {
			items[ 0 ].Val6 = 0;
			items[ 0 ].Val5 = DAMAGE_NORMAL;
			items[ 0 ].Val4 = crafter.SkillBase[ SK_TRAPS ] / 10;
			items[ 0 ].Val3 = crafter.SkillBase[ SK_TRAPS ] / 20;
			items[ 0 ].Val1 = crafter.Id;
			return; }
		case PID_GUNSMITH: {
			items[ 0 ].Val0=crafter.SkillBase [SK_REPAIR];
			return; }
    }

}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Levelup callback.
void player_levelup( Critter& player, uint skillIndex, uint skillUp, uint perkIndex )
{
	if( isDisabledSkill( skillIndex ) )
	{
		player.Say( SAY_NETMSG, "Данный навык временно отключен и не прокачивается." );
		return;
	}
		
    if( skillIndex >= SKILL_BEGIN && skillIndex <= SKILL_END )
    {
        for( ; skillUp != 0; skillUp-- )
        {
            int skillVal = player.SkillBase[ skillIndex ];
            if( skillVal >= MAX_SKILL_VAL )
                break;

            int needPoints = 1;
            if( skillVal > __SkillModAdd6 )
                needPoints = 6;
            else if( skillVal > __SkillModAdd5 )
                needPoints = 5;
            else if( skillVal > __SkillModAdd4 )
                needPoints = 4;
            else if( skillVal > __SkillModAdd3 )
                needPoints = 3;
            else if( skillVal > __SkillModAdd2 )
                needPoints = 2;

            if( player.StatBase[ ST_UNSPENT_SKILL_POINTS ] < needPoints )
                break;

            skillVal++;
            if(_CritIsTagSkill(player,skillIndex) && skillVal<MAX_SKILL_VAL) skillVal++; //Roleplay
            player.SkillBase[ skillIndex ] = skillVal;
            player.StatBase[ ST_UNSPENT_SKILL_POINTS ] -= needPoints;
        }
    }
    else if( perkIndex >= PERK_BEGIN && perkIndex <= PERK_END )
    {
        if( PerkCheck( player, perkIndex ) )
        {
            player.PerkBase[ perkIndex ]++;
            player.StatBase[ ST_UNSPENT_PERKS ]--;
        }
    }

    player.StatBase[ ST_REPLICATION_COST ] = player.Stat[ ST_LEVEL ] * 100;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Turn based callbacks.
// Called on every round begin, return false to disable turn-based
void turn_based_begin( Map& map )
{
    // Try end battle
    if( map.TurnBasedRound > 0 )
    {
        uint[] crittersIds;
        map.GetTurnBasedSequence( crittersIds );

        bool continueBattle = false;
        if( crittersIds.length() >= 2 )
        {
            for( uint i = 0, j = crittersIds.length(); i < j; i++ )
            {
                Critter@ cr = ::GetCritter( crittersIds[ i ] );
                if( !( not valid( cr ) || cr.IsDead() ||
                       ( cr.IsNpc() && cr.GetPlanes( AI_PLANE_ATTACK, null ) == 0 ) ||
                       ( cr.IsPlayer() && ( cr.Mode[ MODE_END_COMBAT ] != 0 || cr.Stat[ ST_CURRENT_HP ] < 1 ) ) ) )
                {
                    continueBattle = true;
                    break;
                }
            }
        }

        if( not continueBattle )
            map.EndTurnBased();
    }
}

// Call on end turn-based battle
void turn_based_end( Map& map )
{
    //
}

// Call on every begin and end turn
void turn_based_process( Map& map, Critter& cr, bool beginTurn )
{
    if( beginTurn )
    {
        cr.StatBase[ ST_MOVE_AP ] = cr.Stat[ ST_MAX_MOVE_AP ];
        cr.StatBase[ ST_TURN_BASED_AC ] = 0;
    }
    else
    {
        bool hthEvade = false;
        // if( cr.Perk[ PE_HTH_EVADE ] != 0 )
        // {
            // // In hands only HtH weapons
            // Item@ hand1 = cr.GetItem( 0, SLOT_HAND1 );
            // Item@ hand2 = cr.GetItem( 0, SLOT_HAND2 );
            // if( ( not valid( hand1 ) || hand1.GetType() != ITEM_TYPE_WEAPON || not hand1.Weapon_IsHtHAttack( 0 ) ) &&
                // ( not valid( hand1 ) || hand1.GetType() != ITEM_TYPE_WEAPON || not hand1.Weapon_IsHtHAttack( 0 ) ) )
            // {
                // hthEvade = true;
            // }
        // }

        cr.StatBase[ ST_TURN_BASED_AC ] = cr.Stat[ ST_CURRENT_AP ] * ( hthEvade ? 2 : 1 );
        if( cr.Stat[ ST_TURN_BASED_AC ] < 0 )
            cr.StatBase[ ST_TURN_BASED_AC ] = 0;
        if( hthEvade && cr.Skill[ SK_UNARMED ] > 0 )
            cr.StatBase[ ST_TURN_BASED_AC ] += cr.Skill[ SK_UNARMED ] / 12;
        cr.StatBase[ ST_MOVE_AP ] = 0;
    }
}

// Call when need generate turns sequence
void turn_based_sequence( Map& map, Critter@[]& critters, Critter@ firstTurnCrit )
{
    // Check first turn critter
    if( valid( firstTurnCrit ) && ( firstTurnCrit.IsDead() || firstTurnCrit.Stat[ ST_CURRENT_AP ] <= 0 ) )
        @firstTurnCrit = null;

    // Collect critters
    SequenceCritter[] sequenceCritters;
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        Critter@ cr = critters[ i ];
        if( valid( firstTurnCrit ) && firstTurnCrit.Id == cr.Id )
            continue;
        if( cr.IsDead() )
            continue;
        sequenceCritters.resize( sequenceCritters.length() + 1 );
        @sequenceCritters.last().critter = cr;
    }

    // Sort sequence, see SequenceCritter::opCmp below
    SequenceCritterRandom = Random( 0, 1 );
    sequenceCritters.sortDesc();

    // Fill result
    critters.resize( 0 );
    if( valid( firstTurnCrit ) )
        critters.insertLast( firstTurnCrit );
    for( uint i = 0, j = sequenceCritters.length(); i < j; i++ )
        critters.insertLast( sequenceCritters[ i ].critter );
}

// Sequence sorter for turn_based_sequence
int   SequenceCritterRandom = 0;
class SequenceCritter
{
    Critter@ critter;
    int opCmp( SequenceCritter& in other )
    {
        bool     result;
        Critter@ cr1 = critter;
        Critter@ cr2 = other.critter;
        int      seq1 = cr1.Stat[ ST_SEQUENCE ];
        int      seq2 = cr2.Stat[ ST_SEQUENCE ];
        if( seq1 == seq2 )
        {
            int ag1 = cr1.Stat[ ST_AGILITY ];
            int ag2 = cr2.Stat[ ST_AGILITY ];
            if( ag1 == ag2 )
            {
                int lk1 = cr1.Stat[ ST_LUCK ];
                int lk2 = cr2.Stat[ ST_LUCK ];
                if( lk1 == lk2 )
                {
                    if( SequenceCritterRandom == 0 )
                        result = cr1.Id > cr2.Id;
                    else
                        result = cr1.Id < cr2.Id;
                }
                else
                    result = lk1 > lk2;
            }
            else
                result = ag1 > ag2;
        }
        else
            result = seq1 > seq2;
        return result ? int(1) : int(-1);
    }
}

// Call on world saving
// Range of currentIndex: 1..9999
void world_save( uint currentIndex, uint[]& deleteIndexes )
{
    // Keep only current and four last saves
    if( currentIndex == 1 )
    {
        deleteIndexes.resize( 5 );
        for( uint i = 0; i < 5; i++ )
            deleteIndexes[ i ] = 9999 - i;
    }
    else if( currentIndex > 4 )
    {
        deleteIndexes.resize( 1 );
        deleteIndexes[ 0 ] = currentIndex - 5;
    }

	if(!SaveWorldNextVersion())
		Log("Версия мира в памяти не актуальна.");
		
    SaveCaravans();

    qmap_save_all();

    manager_world_save();
}

uint8 NpcCount( Critter@[]& group )
{
    uint8 x = 0;
    for( uint i = 0, len = group.length(); i < len; i++ )
    {
        if( group[ i ] is null or group[ i ].IsPlayer() )
            continue;
        x++;
    }
    return x;
}
// Call on player try register
// Return true to allow, false to disallow
bool player_registration( uint ip, string& name, uint& textMsg, uint& strNum )
{
    return manager_player_registration( ip, name, textMsg, strNum );
}

// Call on player try login
// Return true to allow, false to disallow
bool player_login( uint ip, string& name, uint id, uint& textMsg, uint& strNum )
{
    if( !manager_player_login( ip, name, id, textMsg, strNum ) )
        return false;

    if (!DllPlayerLogin(ip, name, id))
        return false;

    Critter@ cr = GetCritter( id );

    if( !(cr is null) )
    {
        cr.ParamBase[ ST_QMAP ] = 0;
        CreateTimeEvent( __FullSecond + REAL_MS( 100 ), "e_player_after_login", id, false );


        // cr.Wait(0);
        // cr.ParamBase[MODE_WAIT]=0;
        // cr.SetEvent(CRITTER_EVENT_IDLE, null);
    }

    return true;
}

uint e_player_after_login( uint[] @ values )
{
    if( (values is null) || values.length() < 1 )
    {
        Log( "there isn't id in values" );
        return 0;
    }

    uint     id = values[ 0 ];

    Critter@ cr = GetCritter( id );

    if( cr is null )
    {
        Log( "can't get player " + id );
        return 0;
    } else {
    	//FlushScreen (cr, COLOR_BLACK, 0, 20000);
    }

    DllPlayerAfterLogin(cr);

    Map@ map = cr.GetMap();

    if( !(map is null) && uint( cr.Param[ ST_QMAP ] ) == 0 )
    {
        qmap_critter_in( map.Id, cr );
    }

    return 0;
}

void SetStartCrTimeEvent( Critter& cr, string func, uint time, int identifier, uint rate )
{
    if( cr.GetTimeEvents( identifier, null, null, null ) > 0 )
    {
        cr.Say( SAY_NETMSG, "erase" );
        cr.EraseTimeEvents( identifier );
    }

    cr.AddTimeEvent( func, time, identifier, rate );

}

// Call on player try change access
// Return true to allow, false to disallow
bool player_getaccess( Critter& player, int access, string& password )
{
    Log( "Access changed for player " + player.Name + ", from " + player.GetAccess() + " to " + access + "." );
    player.StatBase[ ST_ACCESS_LEVEL ] = access;
    return true;
}

bool player_allowcommand( Critter@ player, string@ adminPanel, uint8 command )
{
    if( valid( adminPanel ) )
        return true;

    switch( command )
    {
    // ACCESS_CLIENT
    case COMMAND_CHANGE_PASSWORD:
    case COMMAND_DELETE_ACCOUNT:
    case COMMAND_EXIT:
    case COMMAND_GETACCESS:
    case COMMAND_MYINFO:
        return true;
    // ACCESS_TESTER
    case COMMAND_DROP_UID:
    case COMMAND_PARAM:
    case COMMAND_TOGLOBAL:
        if( player.GetAccess() >= ACCESS_TESTER )
            return true;
        break;
    // ACCESS_MODER
    case COMMAND_ADDITEM:
    case COMMAND_ADDITEM_SELF:
    case COMMAND_ADDLOCATION:
    case COMMAND_ADDNPC:
    case COMMAND_BAN:
    case COMMAND_CHECKVAR:
    case COMMAND_CRITID:
    case COMMAND_DISCONCRIT:
    case COMMAND_GAMEINFO:
    case COMMAND_KILLCRIT:
    case COMMAND_MOVECRIT:
    case COMMAND_RESPAWN:
    case COMMAND_SETVAR:
        if( isGM( player ) )
            return true;
        break;
    // ACCESS_ADMIN
    case COMMAND_LOADDIALOG:
    case COMMAND_LOADLOCATION:
    case COMMAND_LOADMAP:
    case COMMAND_LOADSCRIPT:
    case COMMAND_LOG:
    case COMMAND_RELOAD_CLIENT_SCRIPTS:
    case COMMAND_RELOADAI:
    case COMMAND_RELOADDIALOGS:
    case COMMAND_RELOADLOCATIONS:
    case COMMAND_RELOADMAPS:
    case COMMAND_RELOADSCRIPTS:
    case COMMAND_RELOADTEXTS:
    case COMMAND_REGENMAP:
    case COMMAND_RUNSCRIPT:
    case COMMAND_SETTIME:
        if( player.GetAccess() == ACCESS_ADMIN )
            return true;
        break;
    // Unknown command
    default:
        player.Say( SAY_NETMSG, "Unknown command." );
        return false;
    }

    player.Say( SAY_NETMSG, "Access denied." );
    return false;
}

void _giveHair( Critter& cr, uint index, int oldValue )
{
    SetHair( cr );
}

bool ltp_sharp_inited = false;

void ltp_sharp_init()
{
    LTPREG( LTP_SHARP, process_sharp )
    ltp_sharp_inited = true;
}

uint process_sharp( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESSD( LTP_SHARP )
    Item @ item = GetItem( param0 );
    if( @item == null )
        return 0;
    int8 det = GetDeteriorationProcent( item );
    det -= Random( 1, cr.Stat[ ST_STRENGTH ] );
    det = CLAMP( det, 0, 100 );
    SetDeterioration( item, det );

    cr.Say( SAY_NETMSG, "Вы точите лезвия." );
    return det > 0 ? 3 * 1000 : 0;
}

//import void ShowInputBoxScreen( Critter& cr, string funcName, uint16 textLength, uint8 flags ) from "main";
void ShowInputBoxScreen( Critter& cr, string funcName, uint16 textLength, uint8 flags ) //exported
{
    cr.RunClientScript( "client_screen_inputbox@ShowInputBox", int(textLength), int(flags), 0, funcName, null );
}

void showBunch( Critter& cr, uint answerI, string& answerS )
{

    Item @ item = GetItem( answerI );
    Item @ locker = GetItem( cr.StatBase[ ST_LAST_DOOR_ID ] );
    if( item is null || locker is null )
        return;

	cr.Say( SAY_EMOTE, "" + answerI );
		
    UseItemOnLocker( cr, locker, item );
}

void unsafe_DKP(Critter& cr, int drugPid, int, int, string@, int[]@){

	Item @ drug = _CritGetItem(cr, drugPid);
	if(!(drug is null)){
		if(cr.StatBase[ST_CURRENT_AP] >= 2){
			cr.StatBase[ST_CURRENT_AP] -= 2;
			//cr.Animate
			critter_use_item(cr, drug, null, null, null, 0);
		}
	}
}

uint cte_bodyswap (Critter& cr, int identifier, uint& rate) {
	Critter@ targetCr = GetCritter (cr.Param [P_CRITTER_ID]);
	if (valid (targetCr)) {
		cr.Say (SAY_NETMSG, "Вы возвращаетесь в свое тело");
		targetCr.Say (SAY_NETMSG, "Вы возвращаетесь в свое тело");
		cr.ParamBase [P_BODYSWAPPED] = 0;
		targetCr.ParamBase [P_BODYSWAPPED] = 0;
		SwapCritters (cr, targetCr, true, false);
		cr.Disconnect ();
		targetCr.Disconnect ();
		return 0;
	} else {
		return 10*__TimeMultiplier;
	}
}

void unsafe_MakeDescLex( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	MakeDescLex( player, 0, param3 );
}

void unsafe_ShowFullPopupInfo( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Map@ map = player.GetMap();
	if(!valid(map)) return;
	Item@ target = map.GetItem(param0);
	if(!valid(target)) return;
	int id = target.Val0;
	player.Say( SAY_NETMSG, param3 + " [" + ( id != 0 ? GetPlayerName(id) + ", id " + id : "ZERO ERROR" ) + "]"  );
	if( target.Val1 == 1 )
		map.SetText( player.HexX, player.HexY, COLOR_RGB(0xFF,0x00,0xFF), param3 );
}

void unsafe_ShowPopup( Critter& player, int itemID, int param1, int param2, string@ text, int[] @ param4 )
{
    Map@ map = player.GetMap();
	if(!valid(map)) return;
	Item@ target = map.GetItem(itemID);
	if(!valid(target)) return;
	if( GetDistantion( target.HexX, target.HexY, player.HexX, player.HexY ) > 0 ) { 
		DeleteItem(target);
		return;
	}
	if( target.Val1 == 1 )
		map.SetText( player.HexX, player.HexY, COLOR_RGB(0xFF,0x00,0xFF), text );
	else 
		player.Say( SAY_NETMSG, text );
}

void MakeDescLex( Critter& player, uint answerI, string& answerS ) {
    if( !valid(player) ) return;
    int item_id = player.Stat[ ST_LAST_DOOR_ID ];
    int accessory = player.Stat[ ST_LAST_CONT_ID ];
    Item@ target;
    Map@ map = player.GetMap();
    switch(accessory) {
        case(ACCESSORY_NONE):      player.Say( SAY_NETMSG, "Что-то явно пошло не так!" ); break;
        case(ACCESSORY_CRITTER):   @target = player.GetItemById(item_id); break;
        case(ACCESSORY_HEX):       if(valid(map)) @target = map.GetItem(item_id); break;
        case(ACCESSORY_CONTAINER): player.Say( SAY_NETMSG, "Сначала достаньте предмет из контейнера!" );break;
        default: player.Say( SAY_NETMSG, "Что-то пошло не так.." );
    }
    if( !valid(target) ) {
        player.Say( SAY_NETMSG, "Предмет не найден!" );
        return;
    }
    target.SetLexems( null ); //Очистка прошлых лексем.
    if( answerS.length() > 1 ) 
	{
        player.Say( SAY_NETMSG, "Теперь этот предмет имеет отличительные особенности." );
        target.SetLexems( answerS );
    } 
	else 
	{
        player.Say( SAY_NETMSG, "Вы сделали так, что бы этот предмет больше ничем не выделялся." );
    }
    target.Update();
}	

////////////////////////////ХЕРНЯ ДЛЯ ПИРАТА///////////////

void unsafe_SayText( Critter& player, int SayType, int param1, int param2, string@ text, int[] @ param4 )
{
	player.Say( SayType, text );
}

void unsafe_Harvesting( Critter& player, int pid, int looted, int param2, string@ text, int[] @ param4 ) 
{
	if( player.GetAccess() >= ACCESS_MODER ) {}
	else {
		Map@ map = player.GetMap();
		if( !valid(map) ) return;
		Item@ holder = map.AddItem( player.HexX, player.HexY, PID_POPUP , 1 );
		uint[] values = { holder.Id };
		CreateTimeEvent( __FullSecond + REAL_MINUTE( Random( 5, 90 ) ), "e_RefreshLoot", values, false );
		int time = ( 11 - player.Stat[ ST_LUCK ] ) * REAL_SECOND( 3 );
		player.AddTimeEvent( "cte_Tired", time, CTE_TIRED, 0 );
		player.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + time;
	}
	if( looted == 1 )
		player.AddItem( pid, Random(1,4) );
}

uint cte_Tired( Critter& cr, int identifier, uint& rate )
{
	string[] text = { "отдохнули", "готовы работать дальше", "дали отдых рукам", "слегка передохнули", "чувствуете прилив сил", "можете продолжать"};
	cr.Say(SAY_NETMSG, "Вы "+ text[Random(0,text.length()-1)] + ".");
    return 0;
}

uint e_RefreshLoot( uint[] @ values ) 
{
	Item @ holder = GetItem( values[ 0 ] );
	if( valid(holder) ) DeleteItem(holder);
	return 0;
}

/////////////////////////////////////////

int[][] armor_delay = {
	{ PID_POWERED_ARMOR, PID_HARDENED_POWER_ARMOR, PID_ADVANCED_POWER_ARMOR, PID_ADVANCED_POWER_ARMOR_MK2 },
	{ PID_PURPLE_ROBE, PID_KEEPBRIGE_ROBE, PID_BLACK_ROBE, PID_SANDROBE },
	{ PID_LEATHER_JACKET, PID_CURED_LEATHER_ARMOR, PID_CURED_LEATHER_ARMOR_MK_II },
	{ PID_LEATHER_ARMOR, PID_LEATHER_ARMOR_MK_II, PID_LEATHER_ARMOR_MK_III },
	{ PID_METAL_ARMOR, PID_METAL_ARMOR_MK_II, PID_TESLA_ARMOR},
};

void TryToTakeArmor( Critter& cr, Critter& target ) {
	bool success = false;
	Item@[] armors;
	uint count = target.GetItems( SLOT_ARMOR, armors );
	if( count == 0 || !valid(armors[0]) ) return;
	int armor = armors[0].GetProtoId();
	if( armor_delay[0].find( armor ) != -1 ) return; //ПАшки неснимаемые.
	uint delay = cr.Stat[ST_STEAL_COUNT],
			i = 1, iEnd = armor_delay.length();
	for( ;i < iEnd; i++ )
		if( armor_delay[i].find( armor ) != -1 ) {
			success = true;
			break;
		}
	if( delay >= 6 ) success = true;
	if( success && delay >= i) 
	{
		MoveItem( armors[0], 1, cr );
		target.Say(SAY_NETMSG, "С вас сняли броню.");
		cr.Say(SAY_NETMSG, "Вы сняли броню с жертвы.");
	}
	else cr.Say(SAY_NETMSG, "Итерация №" + delay + " из " +(i==5?6:i)+".");
}

void unsafe_swap_invis( Critter& cr, int, int, int, string@, int[]@ )
{
    if( !isGM( cr ) )
	{
		if( !cr.IsBusy() && !cr.IsDead() && cr.StatBase[ST_CURRENT_HP] > 0 )
		{
			// cr.Say( SAY_EMOTE_ON_HEAD, "присаживается" );
			cr.Animate( 0, ANIM2_PICKUP, null, false, true );
			cr.Wait( 1500 );
		}
		return;
	}
		
	cr.ParamBase[ QST_INVIS ] = CLAMP( 1 - cr.ParamBase[ QST_INVIS ], 0, 1 );
	cr.RefreshVisible();
	//cr.ModeBase[ MODE_HIDE ] = cr.ParamBase[ QST_INVIS ];
	cr.Say( SAY_NETMSG, "Режим суперневидимости " + ( cr.ParamBase[ QST_INVIS ] == 1 ? "в" : "вы" ) + "ключен." );
	//cr.PerkBase[ PE_SILENT_RUNNING ] = cr.ParamBase[ QST_INVIS ];
}

void unsafe_animation( Critter& cr, int type, int val, int targetId, string@, int[]@ )
{
	Critter@ target = @cr;
	if( isGM( cr ) && targetId != 0 )
		@target = GetCritter( targetId );
	
	if( !valid( target ) || target.IsDead() || target.IsKnockout() || target.IsBusy() )
		return;
		
	if( type == ACTION_WINDUP )
	{
		ChangeWindup( target, false );
	}
	else
	{
		if( isGM( cr ) && cr.ParamBase[CR_VAL6] != 0 )
		{
			if( target.GetTimeEvents( CTE_TESTING1, null, null, null ) > 0 )
			{
				target.ParamBase[CR_VAL7] = 0;
				target.EraseTimeEvents( CTE_TESTING1 );
			}
			else
			{
				target.ParamBase[CR_VAL7] = val;
				target.AddTimeEvent( "cte_repeat_anims", 0, CTE_TESTING1, type );
			}
		}
		else
		{
			if( cr.Stat[ ST_CURRENT_AP ] >= 20 )
			{
				target.Action( type, val == 0 ? Random( 0, 1 ) : val - 1, null );
				target.ParamBase[ ST_CURRENT_AP ] -= 20 * 100;
			}
			//cr.Wait( 1000 );
		}
	}
}

uint cte_repeat_anims( Critter& cr, int identifier, uint& rate ) 
{
	cr.Action( rate, cr.ParamBase[CR_VAL7] == 0 ? Random( 0, 1 ) : cr.ParamBase[CR_VAL7] - 1, null );
	return REAL_SECOND(1); 
}

//import void ChangeWindup( Critter& cr, bool ignore_bussy ) from "main";
void ChangeWindup( Critter& cr, bool ignore_bussy )
{
	if( cr.IsPlayer() && !ignore_bussy && cr.IsBusy() )
		return;
		
	cr.Wait( 1000 );
		
	string action_name = "";
	Item@ realWeapon =  _CritGetItemHand(cr);
	if( !valid( realWeapon ) )
		action_name = " кулаки";
	else if( realWeapon.GetType() == ITEM_TYPE_WEAPON )
		action_name = " оружие";
	else
		action_name = " предмет";
	
	ProtoItem@ weapon = valid( realWeapon ) ? GetProtoItem( realWeapon.GetProtoId() ) : null;
	int   skillNum = ( valid( weapon ) ? _WeaponSkill( weapon, 0 ) : ( valid( realWeapon ) ? SK_MELEE_WEAPONS : SK_UNARMED ) );
	uint8 weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : 
						( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );		
	
	if( cr.ParamBase[ CR_IS_WINDUPED ] != 0 )
	{
		cr.ParamBase[ CR_IS_WINDUPED ] = 0;
		if(cr.Anim2Life == ANIM2_WINDUP)
		{
			cr.SetAnims(COND_LIFE, 0, ANIM2_IDLE);
			action_name = "опускает" + action_name;
		}
		else
			return;
	}
	else
	{
		action_name = "вскидывает" + action_name;
		cr.ParamBase[ CR_IS_WINDUPED ] = 1;
		if( weaponSubtype == WS_GUN )
			cr.SetAnims( COND_LIFE, 0, ANIM2_WINDUP );
	}
	
	SayLog( cr, crInfo( cr ) + ":" + action_name + ":" );
	
	if( !ignore_bussy )
		cr.Say( SAY_EMOTE_ON_HEAD, action_name );
}

void unsafe_set_aim( Critter& cr, int aim, int, int, string@, int[]@ )
{
   cr.ParamBase[CR_AUTO_AIM] = aim;
}

void checkTime( Critter& cr, int delta_years, int style, int )
{
	getIngameTime( cr, style, delta_years );
}

void unsafe_getIngameTime( Critter& cr, int style, int delta_years, int, string@, int[]@ )
{
	getIngameTime( cr, style, delta_years );
}
import string CurrentDateTimeYears( uint gameTime, int delta_years, int style ) from "time";
//import string CurrentDateTime( uint gameTime, int delta_time, int style ) from "time";
void getIngameTime( Critter& cr, int style, int delta_years )
{
	if( !isGM( cr ) )
	{
		style = -1;
		delta_years = GetLocationTimeDeltaYears( cr );
	}
	else
		style = 8;
	
	if( style == -1 )
		style = CLAMP( ( cr.Stat[ ST_INTELLECT ] * 20 + cr.Skill[ SK_OUTDOORSMAN ] + cr.Skill[ SK_SCIENCE ] * 2 ) / 100, 0, 7 );
		
	if (style < 6)
        {
            if  ((_CritCountItem( cr, PID_CLOCK )>0) || (_CritCountItem( cr, PID_CORNELIUS_GOLD_WATCH) >0))
			
            style =10;
        }
	
	if( cr.Param[ QST_GAMEMODE ] == GAME_TEST )
	{
		cr.Say ( SAY_NETMSG, "Ваш индекс равен: " + style + "." );
		for( style = 0; style < 11; style++ )
			cr.Say( SAY_NETMSG, CurrentDateTimeYears( __FullSecond, delta_years, style ) );
		return;
	}
	
	cr.Say( SAY_NETMSG, CurrentDateTimeYears( __FullSecond, delta_years, style ) );
}

string GetLocationTimeString( Critter& cr ) //default full info
{
	return GetLocationTimeString( cr.GetMap() );
}

string GetLocationTimeString( Map@ map ) //default full info
{
	return CurrentDateTimeYears( __FullSecond, GetLocationTimeDeltaYears( map ), 9 );
}

string GetLocationTimeString( Critter& cr, int style )
{
	return GetLocationTimeString( cr.GetMap(), style );
}

string GetLocationTimeString( Map@ map, int style )
{
	return CurrentDateTimeYears( __FullSecond, GetLocationTimeDeltaYears( map ), style );
}

int GetLocationTimeDeltaYears( Critter& cr )
{
	return GetLocationTimeDeltaYears( cr.GetMap() );
}

//Ф-я возвращает уникальные дельты времени для отдельных регионов мира.
int GetLocationTimeDeltaYears( Map@ map )
{
	if( !valid(map) ) 
		return 0;

	GameVar@ DELTA_YEARS = GetLocalVar( LMVAR_DELTA_YEARS, map.Id );
	return DELTA_YEARS.GetValue();
}

bool canPutItemInContainer( Item@ item, Item@ container )
{
	if( !valid( item ) || !valid( container ) )
		return false;
	
	uint container_pid = container.GetProtoId();
	uint pid = item.GetProtoId();
	uint type = item.GetType();
	
	
	uint[] proper_paper_containment_pids = { //TODO: Сделать подкатегории предметов: "деньги/бумага" и "мелочи" (маленькие/сжимаемые предметы).
		PID_HOLODISK, PID_MORNING_STAR_MINE, PID_KOKOWEEF_MINE_SCRIP, PID_GOLDEN_COIN, PID_GOLDEN_JEWELRY, PID_BLUE_PASS_KEY, PID_RPSTUFF1,
		PID_BOTTLE_CAPS, PID_REAL_BOTTLE_CAPS, PID_DOG_TAGS, PID_TALISMAN, PID_DOLLAR_100, PID_DOLLAR_20, PID_DOLLAR_5
	};
	
	uint[] paper_container_pids = {
		PID_HANDWRITINGS, PID_PORTMONE, PID_CRAFT_RECIPES, PID_PASSPORT, PID_LETTER, PID_POSTMAN_LETTER, PID_PAPERS_JAMMED,
		PID_ELRON_FIELD_REP, PID_CLIPBOARD, PID_FLIST08, PID_FLIST09, PID_StrpBlt, PID_mgzn01
	};
	if( ( proper_paper_containment_pids.find(pid) == -1 && type != ITEM_TYPE_KEY ) && paper_container_pids.find( container_pid ) != -1 )
		return false; //В "бумажные" и денежные контейнеры можно только вещи из списка proper_paper_containment_pids

	
	uint[] key_container_pids = {
		PID_KEY_BUNCH
	};
	if( type != ITEM_TYPE_KEY && key_container_pids.find( container_pid ) != -1 )
		return false; //В контейнеры-для-ключей (связка ключей и т.п.) нельзя ничего кроме ключей (тип предмета)
	
	
	if( pid == container_pid )
		return false; //В контейнер нельзя засунуть точно такой же тип контейнера.

	if( type == ITEM_TYPE_CONTAINER )
	{ //Когда суём контейнер в контейнер:
		
		//В неподъёмные контейнеры можно совать что угодно.
		//Таким образом, мебель нет нужды добавлять в эти списки, в неё ведь итак по РП можно сунуть что угодно, если она зафиксирована.
		if( !FLAG( container.Flags, ITEM_CAN_PICKUP ) )
			return true; 
		
		//В контейнеры для бумаг денег и ключей нельзя класть другие контейнеры. Просто дополнительная проверка для наглядности.
		if( paper_container_pids.find(container_pid) != -1 || key_container_pids.find(container_pid) != -1 )
			return false;
		
		//Сами же контейнеры для бумаг, денег и ключей можно положить куда угодно.
		if( paper_container_pids.find( pid ) != -1 || key_container_pids.find( pid ) != -1 )
			return true;
		
		//Контейнеры вне таблицы размеров считаются "безразмерными", огромными. 
		//В итоге, их нельзя класть друг в друга, но в них можно класть любые контейнеры, начиная с размера "крупный" и далее по таблице размеров.
		int item_size = -1, container_size = -1;
		
		uint[][] size_table = 
		{ //Внутрь крупных помещается всё что поменьше, и т.д. Градацию можно увеличить, просто разделяя множества на подмножества.
			{ //Предметы из категории "крупные":
				PID_BACKPACK,
				PID_STUFF_SUPPLIES,
			},{ //Предметы из категории "средние".
				PID_SUPER_TOOL_KIT,
				PID_repkit3i,
				PID_repkit2i,
				PID_repkit1i,
				PID_FIRST_AID_KIT,
				PID_FIELD_MEDIC_KIT,
				PID_DOCTORS_BAG,
				PID_PARAMEDICS_BAG,
				PID_BRIEFCASE,
				PID_KEIS,
			},{ //Предметы из категории "мелкие":
				PID_AMMO_BELT,
				PID_BAG,
			}
		};

		//Находим размеры обоих контейнеров (вкладываемый и тот в кого вкладывают):
		for( uint i = 0, maxSize = size_table.length(); i < maxSize; i++ )
			for( uint j = 0, len = size_table[i].length(); j < len; j++ )
			{
				if( size_table[i][j] == pid )
					item_size = i;
				if( size_table[i][j] == container_pid )
					container_size = i;
			}
		
		DebugLog( "Putting #" + pid + "/" + item_size + " in #" + container_pid + "/" + container_size + "." ); //Пока оставил, вдруг что всплывёт - быстро сможем отладить-проверить.
		
		//Если РАЗМЕР вкладываемого БОЛЬШЕ ( т.е. порядковый НОМЕР его категории МЕНЬШЕ, простите за путанницу ) - значит его НЕЛЬЗЯ вложить в контейнер.
		if( item_size <= container_size )
			return false;
	}
	return true;
}

bool map_init( Map& map, bool isfirst )
{
	map.ProccessSleep = Random( 10, 30 );
	return true;
}

//DEPRECATED (ОТКЛЮЧЕННОЕ):

//Все функции с браминами были перенесены в отдельный модуль. 
//Что бы избежать путанницы и битых ссылок, оставил здесь "закрывающую" логику для существующих ивентов.
uint cte_brahmin_pregnancy( Critter& cr, int identifier, uint& rate ) { return 0; }
uint cte_search_partner( Critter& cr, int identifier, uint& rate ) { return 0; }
uint cte_brahmin_growth( Critter& cr, int identifier, uint& rate ) { return 0; }


bool CutCheck( Critter& cr, Item& item, Critter@ target )
{ 
	if( !valid( target ) ) return false;
	
	Map@ map = cr.GetMap();
	if( !valid(map) )
		return testInfo( cr, "На глобале нельзя." );
	
	uint[] knifes = { PID_COMBAT_KNIFE, PID_LIL_JESUS_WEAPON, PID_KNIFE, PID_SWITCHBLADE, PID_WAKIZASHI_BLADE, PID_REVKNIFE1, PID_REVKNIFE2 };
	bool isKnife = knifes.find( item.GetProtoId() ) != -1;

	Item@ hook = map.GetItem( target.HexX, target.HexY, PID_HOLD_HOOK );
	if( !valid( hook ) || target.IsDead() || ( !target.IsPlayer() && target.IsKnockout() ) )
	{
		if( isKnife )
			return e_InitSkinningUse( item, cr, target, null, null );
		
		return testInfo( cr, "Цель не опутана, а этим инструментом её не освежевать." );
	}
	
	testInfo( cr, "Сила опутывания: " + hook.Val5 );
	
	string eff = ( target.Id == cr.Id ? "ся" : "" );
	if( hook.Val5 <= 10 )
	{
		if( !isKnife )
			return inform( cr, "Это здесь не поможет." );

		Item@ net = map.GetItem( target.HexX, target.HexY, PID_REV_BALL1 );
		if( !valid(net) )
			@net = map.GetItem( target.HexX, target.HexY, PID_REV_BALL2 );
		if( valid(net) )
		{
			_SubItem( net, 1 );
			cr.Say( SAY_EMOTE, "Освобождает" + eff );
		}
	}
	else	
	{
		Item@ trap = map.GetItem( target.HexX, target.HexY, PID_TRAP_ACTIVE );
		if( !valid(trap) )
			@trap = map.GetItem( target.HexX, target.HexY, PID_TRAP_DEACTIVATED );
		if( valid(trap) )
		{
			if( item.GetProtoId() != PID_CROWBAR )
				return inform( cr, "Без монтировки тут не обойтись." );

			cr.Say( SAY_EMOTE, "Высвобождает" + eff + " из капкана" );
		}
	}
	
	DeleteItem( hook );
	cr.Animate( 0, ANIM2_SWING_1H, null, false, true );
	target.Say( SAY_NETMSG, "Вы освобождены." );
	return true;
}

//Change pickup flag
bool LockInPlace( Critter& cr, Item& targetItem ) //export to firebarrel
{
	if( !FLAG( targetItem.Flags, ITEM_CAN_PICKUP ) )
	{	
		UNSETFLAG( targetItem.Flags, ITEM_CAN_USE );
		SETFLAG( targetItem.Flags, ITEM_CAN_PICKUP );
		cr.Say( SAY_NETMSG, "|0xFFFF00 Предмет поднимаем, теперь его можно перенести на новое место." );
	}
	else
	{		
		SETFLAG( targetItem.Flags, ITEM_CAN_USE );
		UNSETFLAG( targetItem.Flags, ITEM_CAN_PICKUP );
		cr.Say( SAY_NETMSG, "|0xFFFF00 Предмет надежно закреплен." );
	}
	return true;
}

//Pick up items, max weight and volume check
bool PickItem( Critter& cr, Item& targetItem )
{	
	Item@ item = targetItem;
	if( !FLAG( item.Flags, ITEM_CAN_PICKUP ) )
	{
		cr.Say( SAY_NETMSG, "Это не поднять." );
		return false;
	}	
	
	int freeWeight = cr.Stat[ ST_CARRY_WEIGHT ] - ItemsWeight( cr );
	
	if( cr.Param[ QST_GAMEMODE ] == GAME_TEST )
		cr.Say( SAY_NETMSG, "Поднимаем: " + ItemsWeight( targetItem ) + " грамм." );
	
	if( !isGM( cr ) && !item.IsStackable() && int(ItemsWeight( targetItem )) > freeWeight )
	{
		cr.Say( SAY_NETMSG, "Слишком тяжело." );
		return false;
	}
	
	int amount1 = item.GetCount();
	if( !isGM( cr ) && freeWeight < int( item.Proto.Weight * item.GetCount() ) )
	{
		amount1 = 0;
		if( item.IsStackable() && freeWeight >= int(item.Proto.Weight) )
		{
			amount1 = freeWeight / item.Proto.Weight;
		}	
	}
	
	int freeVolume = CRITTER_MAX_VOLUME - cr.ItemsVolume();
	int amount2 = item.GetCount();
	if( !isGM( cr ) && freeVolume < int( item.Proto.Volume * item.GetCount() ) )
	{
		amount2 = 0;
		if( item.IsStackable() && freeVolume >= int(item.Proto.Volume) )
		{
			amount2 = freeVolume / item.Proto.Volume;
		}
	}
	
	if( amount1 * amount2 != 0 )
	{
		MoveItem( item, MIN( amount1, amount2 ), cr );			
		ChangeCritterSpeed( cr );
	}
	else
	{
		string desc = "Вы не можете это поднять, так как несете ";
		desc += ( amount1 == 0 ? "максимальный груз" + ( amount2 == 0 ? " и " : "" ) : "" );
		desc += ( amount2 == 0 ? "слишком много предметов" : "" );				
		cr.Say( SAY_NETMSG, desc + "." );
	}
	
	return true;
}

#include "behaviours.fos"