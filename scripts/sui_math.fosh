#ifndef __SUI_MATH__
    #define __SUI_MATH__

    // Void vector
    shared class Vector0D 
    {}

    // 1D vector / single math variable
    shared class Vector1D
    {
        float Float;

        Vector1D(float value) final {
            this.Float = value;
        }

        Vector1D@ Recalculate(Vector0D@ ref = null) {
            return this;
        }

        void Calculate() {
            return;
        }

        Formula1D@ opAdd(Vector1D@ right) {
            return Add1D(this, right);
        }

        Formula1D@ opSub(Vector1D@ right) {
            return Sub1D(this, right);
        }

        Formula1D@ opMul(Vector1D@ right) {
            return Mul1D(this, right);
        }

        Formula1D@ opDiv(Vector1D@ right) {
            return Div1D(this, right);
        }

        Formula1D@ opMod(Vector1D@ right) {
            return Mod1D(this, right);
        }

        bool get_Bool() {
            return 0.0f != this.Float;
        }

        string get_String() {
            return "" + this.Float;
        }

        int get_Int() {
            return int(this.Float);
        }

        uint8 get_Uint8() {
            return uint8(this.Float);
        }

        uint16 get_Uint16() {
            return uint16(this.Float);
        }

        uint get_Uint() {
            return uint(this.Float);
        }
    }

    // Basic math operation template
    shared class Formula1D : Vector1D
    {
        Vector0D@ Ref;

        Vector1D@ Left;

        Formula1D(Vector1D@ left) final {
            super(0.0f);
            @this.Left = left;
        }

        Vector1D@ Recalculate(Vector0D@ ref = null) override {
            // Prevent operation from refreshing twice in the same formula call
            if (null is ref) @ref = Vector0D();
            else if (ref is this.Ref) return this;
            @this.Ref = ref;

            // If left variable is an operation, tell it to refresh its value
            Formula1D@ left = cast<Formula1D@>(this.Left);
            if (null !is left) left.Recalculate(ref);

            this.Calculate();
            return this;
        }

        void Calculate() override {
            this.Float = this.Left.Float;
        }

        string get_String() override {
            return "<" + this.Left.String + ">" + this.Float;
        }
    }

    shared class Expression1D : Formula1D
    {
        Vector1D@ Right;
        
        Expression1D(Vector1D@ left, Vector1D@ right) final {
            super(left);
            @this.Right = right;
        }

        Vector1D@ Recalculate(Vector0D@ ref = null) override {
            // Prevent operation from refreshing twice in the same formula call
            if (null is ref) @ref = Vector0D();
            else if (ref is this.Ref) return this;
            @this.Ref = ref;

            // If left variable is an operation, tell it to refresh its value
            Formula1D@ left = cast<Formula1D@>(this.Left);
            if (null !is left) left.Recalculate(ref);

            // If right variable is an operation, tell it to refresh its value
            Formula1D@ right = cast<Formula1D@>(this.Right);
            if (null !is right) right.Recalculate(ref);

            this.Calculate();
            return this;
        }

        string get_String() override {
            return "{" + this.Left.String + "," + this.Right.String + "}=" + this.Float;
        }
    }

    shared final class Add1D : Expression1D 
    {
        Add1D(Vector1D@ left, Vector1D@ right) final {
            super(left, right);
        }

        void Calculate() override {
            this.Float = this.Left.Float + this.Right.Float;
        }

        string get_String() override {
            return "{" + this.Left.String + "+" + this.Right.String + "}=" + this.Float;
        }
    }

    shared final class Sub1D : Expression1D
    {
        Sub1D(Vector1D@ left, Vector1D@ right) final {
            super(left, right);
        }

        void Calculate() override {
            this.Float = this.Left.Float - this.Right.Float;
        }

        string get_String() override {
            return "{" + this.Left.String + "-" + this.Right.String + "}=" + this.Float;
        }
    }

    shared final class Mul1D : Expression1D
    {
        Mul1D(Vector1D@ left, Vector1D@ right) final {
            super(left, right);
        }
        
        void Calculate() override {
            this.Float = this.Left.Float * this.Right.Float;
        }

        string get_String() override {
            return "{" + this.Left.String + "*" + this.Right.String + "}=" + this.Float;
        }
    }

    shared final class Div1D : Expression1D
    {
        Div1D(Vector1D@ left, Vector1D@ right) final {
            super(left, right);
        }
        
        void Calculate() override {
            this.Float = this.Left.Float / this.Right.Float;
        }

        string get_String() override {
            return "{" + this.Left.String + "/" + this.Right.String + "}=" + this.Float;
        }
    }

    shared final class Mod1D : Expression1D
    {
        Mod1D(Vector1D@ left, Vector1D@ right) final {
            super(left, right);
        }
        
        void Calculate() override {
            this.Float = this.Left.Float % this.Right.Float;
        }

        string get_String() override {
            return "{" + this.Left.String + "%" + this.Right.String + "}=" + this.Float;
        }
    }

    shared final class Cmp1D : Expression1D
    {
        Cmp1D(Vector1D@ left, Vector1D@ right) final {
            super(left, right);
        }
        
        void Calculate() override {
            this.Float = (this.Left.Float == this.Right.Float) ? 0.0f : (this.Left.Float < this.Left.Float ? -1.0f : 1.0f );
        }

        string get_String() override {
            return "{" + this.Left.String + "<=>" + this.Right.String + "}=" + this.Float;
        }
    }

    /*
    final class DDDD {
        DDDD() {
            Log("vvvvvvvvvvvvvvvvvvv");

            Vector1D@ x = Vector1D(12.0f);
            Vector1D@ y = Vector1D(13.0f);
            Vector1D@ z = Vector1D(27.5f);
            Formula1D@ formula = (x + y) / z;
            formula.Recalculate();
            Log(formula.String);

            x.Float = 31.0f;
            z.Float = 10.0f;
            formula.Recalculate();
            Log(formula.String);

            Log("^^^^^^^^^^^^^^^^^^^");
        }
    }
    DDDD@ d = DDDD();
    */

#endif
