#include "sui.fosh"

// EXPORT -> sui.fos (once you have r465+ <bool module_init()> just run it there instead of remote import & initializtion)
ModuleSUI@ InstallWASDInputSUI(FrameworkSUI@ sui) {
    return ModuleWASD(sui);
}

// Module master
final class ModuleWASD : ModuleSUI, LoopListenerSUI
{
    // Hotkeys wont listen if false
    bool IsEnabled;

    // Used to make movement north and south take more than 1 tile before chaining right/left
    uint8 VerticalMovementOffset;

    // Current movement action
    MoveActionWASD@ CurrentAction;

    // Module setup
    ModuleWASD(FrameworkSUI@ sui) {
        super(sui);
        sui.AddLoopListener(this);

        this.IsEnabled = false;
        this.VerticalMovementOffset = GetTick() % 1;
        @this.CurrentAction = null;

        //
        // Register hotkeys
        // Feel free to load them from some external source/config
        //

        sui.Hotkeys.Add(SwitchEnabledActionWASD(this, "SPACE + Z"));

        sui.Hotkeys.Add(NorthEastMoveAction(this, "LSHIFT + W + D", true));
        sui.Hotkeys.Add(NorthWestMoveAction(this, "LSHIFT + W + A", true));
        sui.Hotkeys.Add(SouthEastMoveAction(this, "LSHIFT + S + D", true));
        sui.Hotkeys.Add(SouthWestMoveAction(this, "LSHIFT + S + W", true));

        sui.Hotkeys.Add(NorthMoveAction(this, "LSHIFT + W", true));
        sui.Hotkeys.Add(SouthMoveAction(this, "LSHIFT + S", true));
        sui.Hotkeys.Add(WestMoveAction(this, "LSHIFT + A", true));
        sui.Hotkeys.Add(EastMoveAction(this, "LSHIFT + D", true));

        sui.Hotkeys.Add(NorthEastMoveAction(this, "W + D", false));       
        sui.Hotkeys.Add(NorthWestMoveAction(this, "W + A", false));        
        sui.Hotkeys.Add(SouthEastMoveAction(this, "S + E", false));        
        sui.Hotkeys.Add(SouthWestMoveAction(this, "S + W", false));    

        sui.Hotkeys.Add(NorthMoveAction(this, "W", false));
        sui.Hotkeys.Add(SouthMoveAction(this, "S", false));
        sui.Hotkeys.Add(WestMoveAction(this, "A", false));
        sui.Hotkeys.Add(EastMoveAction(this, "D", false));
    }

    // Continue current action in loop if there is one
    void OnLoop() {
        if (null !is this.CurrentAction) {
            this.CurrentAction.Continue();
        }
    }

    // Attempts to move player character to specified location
    void MoveCritter(CritterCl@ player, bool isRun, uint16 hexX, uint16 hexY) {
        uint isRunParam = isRun ? 1 : 0;

        uint[] currentAction;
        GetChosenActions(currentAction);

        // Skip if we are already moving there
        if (
            currentAction.length >= 4 
            && 1 == currentAction[0]
            && uint(hexX) == currentAction[1]
            && uint(hexY) == currentAction[2]
            && isRunParam == currentAction[3]
        ) return;

        // "Do not try to move half of the map around some zero width obstacle"
        int pathLength = GetPathLength(player, hexX, hexY, 0);
        if (pathLength > 4) return;

        // Process obstacles
        if (
            !this.CanMoveCritter(player, hexX, hexY)
            && !(isRun && this.FindWayAround(player, hexX, hexY))
        ) {
            QuakeScreen(1, 30);
            return;
        }

        // Move!
        uint[] action = {1, int(hexX), int(hexY), isRunParam, 0, 0, 0};
        SetChosenActions(action);
    }

    // Checks if path to target hex is clear
    bool CanMoveCritter(CritterCl@ player, uint16 hexX, uint16 hexY) {
        return (player.HexX != hexX || player.HexY != hexY) && 0 != GetPathLength(player, hexX, hexY, 0);
    }

    // Simulates vertical movement in hexagonal space
    void FindVerticalPath(CritterCl@ player, uint16& hexX, uint16& hexY, bool north)
    {
        uint16 leftHexX = player.HexX, rightHexX = player.HexX;
        uint16 leftHexY = player.HexY, rightHexY = player.HexY;
        
        if (north) {
            MoveHexByDir(leftHexX, leftHexY, 5, 1);
            MoveHexByDir(rightHexX, rightHexY, 0, 1);
        } else {
            MoveHexByDir(leftHexX, leftHexY, 3, 1);
            MoveHexByDir(rightHexX, rightHexY, 2, 1);
        }

        // Can move north-west
        bool leftPossible = this.CanMoveCritter(player, leftHexX, leftHexY);
        
        // Can move north-east
        bool rightPossible = this.CanMoveCritter(player, rightHexX, rightHexY);
        
        if (leftPossible && (!rightPossible || 2 > this.VerticalMovementOffset)) 
        {
            this.VerticalMovementOffset+=1;
            if (this.VerticalMovementOffset == 2) {
                this.VerticalMovementOffset = 3;
            }
            hexX = leftHexX;
            hexY = leftHexY;
        }
        else if (rightPossible && (!leftPossible || 2 <= this.VerticalMovementOffset)) {
            this.VerticalMovementOffset-=1;
            if (this.VerticalMovementOffset == 1) {
                this.VerticalMovementOffset = 0;
            }
            hexX = rightHexX;
            hexY = rightHexY;
        }
    }

    // Attempts to find a way around small obstacles by stepping a bit left/right from the specified direction
    bool FindWayAround(CritterCl@ player, uint16& hexX, uint16& hexY) 
    {
        uint16 nHexX = player.HexX, neHexX = player.HexX, nwHexX = player.HexX;
        uint16 nHexY = player.HexY, neHexY = player.HexY, nwHexY = player.HexY;
        
        MoveHexByDir(nHexX, nHexY, player.Dir, 1);
        if (this.CanMoveCritter(player, nHexX, nHexY)) {
            hexX = nHexX;
            hexY = nHexY;
            return true;
        }

        MoveHexByDir(neHexX, neHexY, player.Dir + 1 > 5 ? 0 : player.Dir + 1, 1);
        if (this.CanMoveCritter(player, neHexX, neHexY)) {
            hexX = neHexX;
            hexY = neHexY;
            return true;
        }

        MoveHexByDir(nwHexX, nwHexY, int(player.Dir) - 1 < 0 ? 5 : player.Dir - 1, 1);
        if (this.CanMoveCritter(player, nwHexX, nwHexY)) {
            hexX = nwHexX;
            hexY = nwHexY;
            return true;
        }

        return false;
    }
}

// Abstract module hotkey action
class ActionWASD : HotkeyActionSUI
{
    ModuleWASD@ Module;
    
    ActionWASD(ModuleWASD@ module, string keyState) {
        @this.Module = module;
        super(module.SUI);

        this.AddKeyState(keyState);
    }
}

// Switch module enabled/disabled
final class SwitchEnabledActionWASD : ActionWASD
{
    SwitchEnabledActionWASD(ModuleWASD@ module, string keyState) {
        super(module, keyState);
    }

    void Run(KeyStateEventSUI@ event, KeyStateSUI@ keyState) override {
        if (!this.IsDown) return;

        this.Module.IsEnabled = !this.Module.IsEnabled;

        Message("WASD-раскладка " + (this.Module.IsEnabled ? "включена" : "отключена"));
    }
}

// Abstract moving action
class MoveActionWASD : ActionWASD 
{
    CritterCl@ Player;
    uint16 HexX;
    uint16 HexY;
    bool IsRun;

    MoveActionWASD(ModuleWASD@ module, string keyState, bool isRun) {
        super(module, keyState);
        this.IsRun = isRun;
    }

    void Run(KeyStateEventSUI@ event, KeyStateSUI@ keyState) override {
        if (!this.IsDown) {
            if (this.Module.CurrentAction is this && this.Module.CurrentAction.IsRun == this.IsRun) {
                @this.Module.CurrentAction = null;
            }
            return;
        }

        if (this.Module.IsEnabled) {
            event.StopProcessing = event.StopPropagation = true;
            if (@this.Module.CurrentAction !is this) {
                @this.Module.CurrentAction = this;
            }
            this.Continue();
        }
    }

    // Continue movement
    void Continue() {
        @this.Player = GetChosen();
        // Prevent from running on non-game screens
        if (null is this.Player) return;

        this.HexX = this.Player.HexX;
        this.HexY = this.Player.HexY;
    }
}

// Moves in simulated vertical space
class VerticalMoveAction : MoveActionWASD
{
    bool IsNorth;

    VerticalMoveAction(ModuleWASD@ module, string keyState, bool isRun) {
        super(module, keyState, isRun);
    }

    void Continue() {
        MoveActionWASD::Continue();

        uint[] currentAction;
        GetChosenActions(currentAction);

        if (
            this.Module.CurrentAction is this
            && this.IsRun == this.Module.CurrentAction.IsRun
            && currentAction.length >= 4
            && currentAction[0] == 1
        ) {
            // Already moving that way
            return;
        }

        this.Module.FindVerticalPath(this.Player, this.HexX, this.HexY, this.IsNorth);
        this.Module.MoveCritter(this.Player, this.IsRun, this.HexX, this.HexY);
    }
}

// Move north (top)
final class NorthMoveAction : VerticalMoveAction
{
    NorthMoveAction(ModuleWASD@ module, string keyState, bool isRun) {
        super(module, keyState, isRun);
        this.IsNorth = true;
    }
}

// Move south (bottom)
final class SouthMoveAction : VerticalMoveAction
{
    SouthMoveAction(ModuleWASD@ module, string keyState, bool isRun) {
        super(module, keyState, isRun);
        this.IsNorth = false;
    }
}

// Move in hexagonal space
class HexagonalMoveAction : MoveActionWASD
{
    uint8 Dir;
    uint  Steps;

    HexagonalMoveAction(ModuleWASD@ module, string keyState, bool isRun) {
        super(module, keyState, isRun);
    }

    void Continue() {
        MoveActionWASD::Continue();
        MoveHexByDir(this.HexX, this.HexY, this.Dir, this.Steps);
        this.Module.MoveCritter(this.Player, this.IsRun, this.HexX, this.HexY);
    }
}

// Move north-east (top-left)
final class NorthEastMoveAction : HexagonalMoveAction 
{
    NorthEastMoveAction(ModuleWASD@ module, string keyState, bool isRun) {
        super(module, keyState, isRun);
        this.Dir = 0;
        this.Steps = 1;
    }
}

// Move east (left)
final class EastMoveAction : HexagonalMoveAction 
{
    EastMoveAction(ModuleWASD@ module, string keyState, bool isRun) {
        super(module, keyState, isRun);
        this.Dir = 1;
        this.Steps = 1;
    }
}

// Move south-east (botton-right)
final class SouthEastMoveAction : HexagonalMoveAction 
{
    SouthEastMoveAction(ModuleWASD@ module, string keyState, bool isRun) {
        super(module, keyState, isRun);
        this.Dir = 2;
        this.Steps = 1;
    }
}

// Move south-west (bottom-left)
final class SouthWestMoveAction : HexagonalMoveAction 
{
    SouthWestMoveAction(ModuleWASD@ module, string keyState, bool isRun) {
        super(module, keyState, isRun);
        this.Dir = 3;
        this.Steps = 1;
    }
}

// Move west (left)
final class WestMoveAction : HexagonalMoveAction 
{
    WestMoveAction(ModuleWASD@ module, string keyState, bool isRun) {
        super(module, keyState, isRun);
        this.Dir = 4;
        this.Steps = 1;
    }
}

// Move north-west (top-left)
final class NorthWestMoveAction : HexagonalMoveAction 
{
    NorthWestMoveAction(ModuleWASD@ module, string keyState, bool isRun) {
        super(module, keyState, isRun);
        this.Dir = 5;
        this.Steps = 1;
    }
}