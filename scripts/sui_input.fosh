#ifndef __SUI_INPUT__
    #define __SUI_INPUT__
    #include "sui.fosh"
    #include "sui_input_events.fosh"
    #include "sui_input_keystate.fosh"

    shared class HotkeyListenerSUI : ModuleSUI, EventListenerSUI
    {
        // Collection of registered hotkey actions
        HotkeyActionSUI@[] HotkeyActions;

        // Current game key state
        KeyStateSUI@ KeyState;

        //
        // Constructor
        //

        HotkeyListenerSUI(FrameworkSUI@ sui) {
            super(sui);

            @this.KeyState = KeyStateSUI();

            this.SUI.AddEventListener(this);
        }

        //
        // Methods
        //

        // Registers hotkey action and returns its ID (whether or not to accept it is decided within hotkey action class)
        void Add(HotkeyActionSUI@ hotkeyAction) {
            this.HotkeyActions.insertLast(hotkeyAction);
            hotkeyAction.HotkeyID = this.HotkeyActions.length - 1;
        }

        // Drop hotkey action by its ID
        void RemoveByIndex(int index) {
            this.HotkeyActions.removeAt(index);
        }

        // Generic input event handler
        void OnEvent(EventSUI@ event) final {
            EngineEventSUI@ engineEvent = cast<EngineEventSUI>(event);
            
            // Ignore all non-input events
            if (null is event || null is engineEvent || null is cast<InputEventSUI>(event)) {
                return;
            }

            // For now, ignore mouse movement input events as well
            MouseMoveEventSUI@ mouseMoveEvent = cast<MouseMoveEventSUI@>(event);
            if (null !is mouseMoveEvent) {
                return;
            }

            // Apply keyboard button down/up
            KeyboardStateEventSUI@ keyboardStateEvent = cast<KeyboardStateEventSUI@>(event);
            if (null !is keyboardStateEvent) {
                this.KeyState.SetKeyState(keyboardStateEvent.Key, keyboardStateEvent.IsPressed);
            }

            // Apply mouse button down/up
            MouseStateEventSUI@ mouseStateEvent = cast<MouseStateEventSUI@>(event);
            if (null !is mouseStateEvent) {
                this.KeyState.SetMouseState(mouseStateEvent.Key, mouseStateEvent.IsPressed);
            }

            // Apply input loss
            InputLostEventSUI@ inputLostEvent = cast<InputLostEventSUI@>(event);
            if (null !is inputLostEvent) {
                this.KeyState.Flush();
            }

            // @debug dump current key combination
            Message(this.KeyState.GetName());

            // Propagate event to hotkeys as a key state event
            KeyStateEventSUI@ keyStateEvent = KeyStateEventSUI(this.KeyState);
            for (uint i = 0, l = this.HotkeyActions.length; i < l; i++) {
                this.HotkeyActions[i].OnEvent(keyStateEvent);

                bool doBreak = false;

                if (keyStateEvent.StopPropagation) {
                    engineEvent.StopPropagation = doBreak = true;
                }

                if (keyStateEvent.StopProcessing) {
                    engineEvent.StopProcessing = true;
                }

                if (doBreak) break;
            }
        }
    }

    // Hotkey base class to be extended by children hotkeys
    shared class HotkeyActionSUI : ModuleSUI, EventListenerSUI
    {
        uint HotkeyID;

        // Compatible key states to check against current keyboard state
        KeyStateSUI@[] KeyStates;

        // Whether hotkey is in its pressed state
        bool IsDown;

        //
        // Constructor
        //

        HotkeyActionSUI(FrameworkSUI@ sui) final {
            super(sui);

            this.IsDown = false;
            this.KeyStates.resize(0);
        }

        void AddKeyState(KeyStateSUI@ keyState) final {
            this.KeyStates.insertLast(keyState);
        }

        void AddKeyState(string name) final {
            this.AddKeyState(KeyStateSUI(name));
        }

        // Key state event handler
        void OnEvent(EventSUI@ event) final {
            if (null is event) return;

            // Skip non key state events (tho there should not be any of these)
            KeyStateEventSUI@ keyStateEvent = cast<KeyStateEventSUI>(event);
            if (null is keyStateEvent) return;

            // Check if received key state matches any of whitelisted key states
            KeyStateSUI@ match = null;
            bool isDown = false;
            for (uint i = 0, l = this.KeyStates.length; i < l; i++) {
                if (keyStateEvent.KeyState.Has(this.KeyStates[i])) {
                    @match = this.KeyStates[i];
                    isDown = true;
                    break;
                }
            }

            // Switch hotkey state
            if (this.IsDown != isDown) {
                this.IsDown = isDown;
                this.Run(keyStateEvent, match);
            }
        }

        // Override this with your action
        void Run(KeyStateEventSUI@ event, KeyStateSUI@ keyState) {}

        string GetNameLabel() {
            return "Unnamed";
        }

        string GetDescriptionLabel() {
            return "Please, add name and description for this hotkey action";
        }

        string@[] GetHotkeyLabels(string delimiter = " + ") final {
            string@[] result;
            for (uint i = 0, l = this.KeyStates.length; i < l; i++) {
                result.insertLast(this.KeyStates[i].GetName(delimiter));
            }
            return result;
        }
    }

#endif